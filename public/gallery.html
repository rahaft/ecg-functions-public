<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECG Image Gallery</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .gallery-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .gallery-item {
            background: var(--card-bg);
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: var(--shadow);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }
        
        .gallery-item:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
        }
        
        .gallery-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            display: block;
        }
        
        .gallery-item-info {
            padding: 1rem;
        }
        
        .gallery-item-info h3 {
            font-size: 0.875rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            word-break: break-all;
        }
        
        .gallery-item-info p {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }
        
        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }
        
        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        .version-footer {
            margin-top: 4rem;
            padding: 2rem 0;
            border-top: 1px solid var(--border-color);
            text-align: center;
        }
        
        .version-info {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            gap: 0.75rem;
            white-space: nowrap;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }
        
        .version-info:hover {
            background-color: #e9ecef;
        }
        
        .version-info .separator {
            color: #ccc;
            margin: 0 0.25rem;
        }
        
        .version-copy-btn {
            margin-left: 1rem;
            padding: 0.5rem 1rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background-color 0.2s;
        }
        
        .version-copy-btn:hover {
            background: var(--primary-hover);
        }
        
        .version-copy-btn.copied {
            background: var(--success-color);
        }
    </style>
    
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        // Removed Firebase Storage - using only Google Cloud Storage (GCS)
        
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyAsIWxy1gTV1_e9ZXZnaplcOWqU9PwL_Uc",
            authDomain: "hv-ecg.firebaseapp.com",
            projectId: "hv-ecg",
            storageBucket: "hv-ecg.appspot.com",
            messagingSenderId: "101881880910",
            appId: "1:101881880910:web:2320e56f5dcaaa46febe1f"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        // Removed Firebase Storage - using only Google Cloud Storage (GCS) URLs directly
        
        // Auto sign in anonymously
        signInAnonymously(auth).catch(console.error);
        
        // Version info
        const APP_VERSION = '2.4.1';
        const BUILD_TIMESTAMP = '2026.01.22.2320';
        const BUILD_DATE = new Date();
        
        // Python service URL (Cloud Run)
        const PYTHON_SERVICE_URL = 'https://ecg-multi-method-101881880910.us-central1.run.app';
        
        // GCS Configuration
        const GCS_BUCKETS = [
            'ecg-competition-data-1',
            'ecg-competition-data-2',
            'ecg-competition-data-3',
            'ecg-competition-data-4',
            'ecg-competition-data-5'
        ];
        const GCS_PREFIX = 'kaggle-data/physionet-ecg/';
        const MANIFEST_URL = '/gcs_images_manifest.json'; // Hosted on Firebase Hosting
        
        // Global state
        let images = [];
        let allGroups = [];
        let displayedGroups = 0;
        const IMAGES_PER_SET = 9;  // One set = 9 images
        const SETS_PER_LOAD = 1;   // Initial load: 1 set (9 images)
        const SETS_PER_LOAD_MORE = 2; // Load More: 2 sets (18 images)
        
        // Processing state
        let processingGroups = new Set();
        let processedImages = new Map(); // groupKey -> {images: [], subImages: {}}
        let collapsedGroups = new Set(); // Track which groups are collapsed
        let currentSetIndex = 0; // Track current set index for "Next Set" functionality
        
        // Helper function to extract image number from filename for sorting
        function extractImageNumber(filename) {
            if (!filename) return 0;
            
            // Try to extract number after dash (e.g., "1006427285-0003.png" -> 3)
            const dashMatch = filename.match(/-(\d+)/);
            if (dashMatch) {
                return parseInt(dashMatch[1], 10);
            }
            
            // Try to extract number from end of filename before extension
            const endMatch = filename.match(/(\d+)\.(png|jpg|jpeg|tiff|tif)$/i);
            if (endMatch) {
                return parseInt(endMatch[1], 10);
            }
            
            // Try to extract any sequence of digits
            const anyMatch = filename.match(/(\d+)/);
            if (anyMatch) {
                return parseInt(anyMatch[1], 10);
            }
            
            // Fallback: return 0 for alphabetical sort
            return 0;
        }
        
        // Load images from GCS buckets via manifest
        async function loadImages() {
            const galleryGrid = document.getElementById('gallery-grid');
            const loadingEl = document.getElementById('loading');
            
            loadingEl.textContent = 'Loading images from GCS...';
            
            try {
                // Try to load from manifest
                let manifestData = null;
                try {
                    const manifestResponse = await fetch(MANIFEST_URL);
                    if (manifestResponse.ok) {
                        manifestData = await manifestResponse.json();
                        console.log('‚úì Loaded manifest from', MANIFEST_URL);
                    } else {
                        console.warn('Manifest not found, status:', manifestResponse.status);
                    }
                } catch (e) {
                    console.warn('Manifest not available:', e);
                }
                
                images = [];
                
                if (manifestData && manifestData.images) {
                    // Use manifest data - handle both formats
                    images = manifestData.images.map(img => ({
                        name: img.name || img.filename,
                        path: img.path || img.gcs_path,
                        url: img.url || img.gcs_public_url,
                        bucket: img.bucket || img.gcs_bucket,
                        folder: img.folder || '',
                        is_train: img.is_train || false,
                        is_test: img.is_test || false
                    }));
                } else {
                    // No manifest available
                    loadingEl.innerHTML = `
                        <div class="empty-state">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <rect x="3" y="3" width="18" height="18" rx="2" stroke-width="2"/>
                                <path d="M9 9h6v6H9z" stroke-width="2"/>
                            </svg>
                            <h2>Manifest not found</h2>
                            <p>Run: <code>python scripts/convert_manifest_for_gallery.py</code></p>
                            <p>Then: <code>copy gcs_images_manifest.json public\gcs_images_manifest.json</code></p>
                            <p>Then: <code>firebase deploy --only hosting</code></p>
                        </div>
                    `;
                    return;
                }
                
                // Group images by prefix (before -) or by folder
                const grouped = {};
                images.forEach(img => {
                    // Try to extract prefix before '-' in filename
                    let groupKey = img.folder || 'other';
                    
                    // If filename has '-', use prefix before it
                    if (img.name && img.name.includes('-')) {
                        groupKey = img.name.split('-')[0];
                    } else if (img.folder) {
                        // Use folder name (test/train) as group
                        groupKey = img.folder;
                    } else {
                        // Fallback: use first part of filename
                        groupKey = img.name ? img.name.split('.')[0] : 'other';
                    }
                    
                    if (!grouped[groupKey]) {
                        grouped[groupKey] = {
                            key: groupKey,
                            images: [],
                            folder: img.folder || '',
                            is_train: img.is_train || false,
                            is_test: img.is_test || false
                        };
                    }
                    grouped[groupKey].images.push(img);
                });
                
                // Sort images within each group by image number
                Object.values(grouped).forEach(group => {
                    group.images.sort((a, b) => {
                        return extractImageNumber(a.name) - extractImageNumber(b.name);
                    });
                });
                
                // Render gallery
                if (images.length === 0) {
                    loadingEl.innerHTML = `
                        <div class="empty-state">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <rect x="3" y="3" width="18" height="18" rx="2" stroke-width="2"/>
                                <path d="M9 9h6v6H9z" stroke-width="2"/>
                            </svg>
                            <h2>No images found</h2>
                            <p>Images are stored in GCS buckets. Generate manifest to display them.</p>
                        </div>
                    `;
                } else {
                    loadingEl.style.display = 'none';
                    galleryGrid.innerHTML = '';
                    
                    // Sort groups by key (images within groups are already sorted by number)
                    const sortedGroups = Object.values(grouped).sort((a, b) => {
                        // Put train first, then test, then others
                        if (a.is_train && !b.is_train) return -1;
                        if (!a.is_train && b.is_train) return 1;
                        if (a.is_test && !b.is_test) return -1;
                        if (!a.is_test && b.is_test) return 1;
                        return a.key.localeCompare(b.key);
                    });
                    
                    // Store groups and render with pagination
                    allGroups = sortedGroups;
                    displayedGroups = 0;
                    renderGroups();
                    
                    // Populate dropdown
                    populateGroupDropdown();
                    
                    console.log(`Loaded ${images.length} images in ${allGroups.length} groups from GCS`);
                }
            } catch (error) {
                console.error('Error loading images:', error);
                loadingEl.textContent = `Error: ${error.message}`;
            }
        }
        
        // Render groups with pagination (by sets of 9 images)
        function renderGroups() {
            const galleryGrid = document.getElementById('gallery-grid');
            let imagesDisplayed = 0;
            const maxImages = displayedGroups === 0 ? 
                (SETS_PER_LOAD * IMAGES_PER_SET) : 
                (SETS_PER_LOAD_MORE * IMAGES_PER_SET);
            
            // Render groups until we hit the image limit
            for (let i = displayedGroups; i < allGroups.length; i++) {
                const group = allGroups[i];
                
                // Check if we've hit image limit
                if (imagesDisplayed + group.images.length > maxImages) {
                    // Show partial group if there's room
                    const remainingImages = maxImages - imagesDisplayed;
                    if (remainingImages > 0) {
                        renderGroup(group, remainingImages);
                        imagesDisplayed += remainingImages;
                    }
                    break;
                }
                
                renderGroup(group);
                imagesDisplayed += group.images.length;
                displayedGroups++;
            }
            
            // Show/hide "Load More" button
            updateLoadMoreButton();
        }
        
        // Render a single group
        function renderGroup(group, maxImages = null) {
            const galleryGrid = document.getElementById('gallery-grid');
            const imagesToShow = maxImages ? group.images.slice(0, maxImages) : group.images;
            const isCollapsed = collapsedGroups.has(group.key);
            
            // Declare processing state variables FIRST (before using them)
            const isProcessing = processingGroups.has(group.key);
            const isProcessed = processedImages.has(group.key);
            
            // Add group header
            const groupHeader = document.createElement('div');
            groupHeader.className = 'gallery-group-header';
            if (isProcessed) {
                groupHeader.classList.add('processed');
            }
            if (isProcessing) {
                groupHeader.classList.add('processing');
            }
            groupHeader.dataset.groupKey = group.key;
            groupHeader.style.gridColumn = '1 / -1';
            groupHeader.style.marginTop = displayedGroups === 0 ? '0' : '1rem';
            groupHeader.style.marginBottom = '0.5rem';
            groupHeader.style.padding = '1rem';
            groupHeader.style.background = isProcessed ? '#f8f9fa' : 'var(--card-bg)';
            groupHeader.style.borderRadius = '0.5rem';
            groupHeader.style.borderLeft = isProcessed ? '4px solid #28a745' : (isProcessing ? '4px solid #ffc107' : '4px solid var(--primary-color)');
            groupHeader.style.cursor = isProcessed ? 'pointer' : 'default';
            
            // Add click handler to header for processed groups to toggle collapse
            if (isProcessed) {
                groupHeader.onclick = (e) => {
                    // Don't toggle if clicking on buttons
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }
                    toggleGroupCollapse(group.key, e);
                };
            }
            
            const groupLabel = group.folder || group.key;
            const groupType = group.is_train ? 'üìö Train' : group.is_test ? 'üß™ Test' : 'üìÅ';
            
            groupHeader.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                    <div style="flex: 1; display: flex; align-items: center; gap: 0.5rem;">
                        ${isProcessed ? `
                            <button onclick="event.stopPropagation(); toggleGroupCollapse('${group.key}')" 
                                    style="padding: 0.25rem 0.5rem; background: transparent; border: 1px solid #ddd; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem; color: var(--text-secondary);"
                                    title="${isCollapsed ? 'Expand' : 'Collapse'} set">
                                ${isCollapsed ? '‚ñ∂' : '‚ñº'}
                            </button>
                        ` : '<span style="width: 2rem;"></span>'}
                        <div style="flex: 1;">
                            <h2 style="margin: 0; font-size: 1.1rem; color: var(--text-primary);">
                                ${groupType} ${groupLabel}
                                ${isProcessed ? ' <span style="color: green; font-size: 0.875rem;">‚úì Processed</span>' : ''}
                                ${isProcessing ? ' <span style="color: orange; font-size: 0.875rem;">‚è≥ Processing</span>' : ''}
                            </h2>
                            <p style="margin: 0.25rem 0 0 0; font-size: 0.875rem; color: var(--text-secondary);">
                                ${imagesToShow.length}${maxImages && imagesToShow.length < group.images.length ? ` of ${group.images.length}` : ''} image(s) in this set
                            </p>
                        </div>
                    </div>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        ${isProcessed ? `
                            <button class="view-results-btn" 
                                    data-group-key="${group.key}"
                                    onclick="event.stopPropagation(); viewProcessedResults('${group.key}')"
                                    style="padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;"
                                    title="View processed results">
                                üëÅÔ∏è View Results
                            </button>
                            <button class="reset-group-btn" 
                                    data-group-key="${group.key}"
                                    onclick="event.stopPropagation(); resetGroupProcessing('${group.key}')"
                                    style="padding: 0.5rem 1rem; background: #6c757d; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;"
                                    title="Reset processing status">
                                üîÑ Reset
                            </button>
                        ` : ''}
                        <button class="process-group-btn" 
                                data-group-key="${group.key}"
                                onclick="event.stopPropagation(); processGroup('${group.key}')"
                                ${isProcessing ? 'disabled' : ''}
                                style="padding: 0.5rem 1rem; background: ${isProcessing ? '#ccc' : 'var(--primary-color)'}; color: white; border: none; border-radius: 0.375rem; cursor: ${isProcessing ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;">
                            ${isProcessing ? '‚è≥ Processing...' : isProcessed ? 'üîÑ Reprocess' : '‚ö° Process'}
                        </button>
                    </div>
                </div>
            `;
            galleryGrid.appendChild(groupHeader);
            
            // Only render images if not collapsed
            if (isCollapsed) {
                return; // Don't render images if collapsed
            }
            
            // Add images in this group
            imagesToShow.forEach(img => {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                item.dataset.groupKey = group.key;
                item.dataset.imageName = img.name;
                
                // Check if this is the base image (-0001)
                const isBaseImage = img.name.includes('-0001');
                
                // Get sub-images if processed
                const processed = processedImages.get(group.key);
                const subImages = processed?.subImages?.[img.name] || [];
                
                let subImagesHtml = '';
                if (subImages.length > 0 && !isBaseImage) {
                    subImagesHtml = `
                        <div class="sub-images" style="display: flex; gap: 0.5rem; padding: 0.5rem; background: #f5f5f5; flex-wrap: wrap;">
                            ${subImages.map(sub => `
                                <img src="${sub.url}" alt="${sub.name}" 
                                     style="width: 60px; height: 60px; object-fit: cover; border-radius: 4px; cursor: pointer;"
                                     onclick="event.stopPropagation(); window.open('${sub.url}', '_blank')"
                                     title="${sub.name}">
                            `).join('')}
                        </div>
                    `;
                }
                
                // Check if this specific image has been processed
                const imageProcessed = processed?.images?.some(p => 
                    p.original_name === img.name || 
                    p.name === img.name ||
                    p.path === img.path ||
                    p.path === img.name
                );
                
                item.innerHTML = `
                    <img src="${img.url}" alt="${img.name}" loading="lazy" 
                         onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 24 24\\'%3E%3Ctext x=\\'50%25\\' y=\\'50%25\\' text-anchor=\\'middle\\'%3EFailed to load%3C/text%3E%3C/svg%3E';">
                    <div class="gallery-item-info">
                        <h3>${img.name}</h3>
                        <p style="font-size: 0.7rem; color: #888;">${img.bucket || 'unknown'}</p>
                        ${isBaseImage ? '<span style="color: green; font-size: 0.7rem;">Base Image</span>' : ''}
                        ${imageProcessed ? '<span style="color: green; font-size: 0.7rem;">‚úì Processed</span>' : ''}
                    </div>
                    <div style="padding: 0.75rem; display: flex; gap: 0.5rem; justify-content: center; align-items: center; border-top: 1px solid #eee; background: #f9f9f9;">
                        <button class="process-single-image-btn" 
                                data-group-key="${group.key}"
                                data-image-path="${img.path || img.name}"
                                data-image-name="${img.name}"
                                data-bucket="${img.bucket || group.images[0]?.bucket || GCS_BUCKETS[0]}"
                                onclick="processSingleImage('${group.key}', '${img.path || img.name}', '${img.name}', '${img.bucket || group.images[0]?.bucket || GCS_BUCKETS[0]}')"
                                style="padding: 0.5rem 1rem; background: var(--primary-color); color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.8rem; font-weight: 500; flex: 1; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.2s;"
                                onmouseover="this.style.background='var(--primary-hover)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 6px rgba(0,0,0,0.15)';"
                                onmouseout="this.style.background='var(--primary-color)'; this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';"
                                title="Process this individual image">
                            ‚ö° Process Image
                        </button>
                        ${imageProcessed ? `
                            <button class="view-single-result-btn" 
                                    data-group-key="${group.key}"
                                    data-image-name="${img.name}"
                                    onclick="viewSingleImageResult('${group.key}', '${img.name}')"
                                    style="padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.8rem; font-weight: 500; flex: 1; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.2s;"
                                    onmouseover="this.style.background='#218838'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 6px rgba(0,0,0,0.15)';"
                                    onmouseout="this.style.background='#28a745'; this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';"
                                    title="View processed results for this image">
                                üëÅÔ∏è View Results
                            </button>
                        ` : ''}
                    </div>
                    ${subImagesHtml}
                `;
                // Handle click on image (but not on buttons)
                item.onclick = (e) => {
                    // Don't trigger if clicking on a button
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }
                    
                    if (processed && processed.images.length > 0) {
                        // Find matching processed image
                        const processedImg = processed.images.find(p => 
                            p.original_name === img.name || 
                            p.name === img.name ||
                            p.path === img.path ||
                            p.path === img.name
                        );
                        if (processedImg) {
                            openComparisonModal(group.key, processedImg.original_name || processedImg.name);
                        } else {
                            // Open first processed image if exact match not found
                            openComparisonModal(group.key, processed.images[0].original_name || processed.images[0].name);
                        }
                    } else {
                        window.open(img.url, '_blank');
                    }
                };
                
                // Add visual indicator if processed
                if (processed && processed.images.length > 0) {
                    item.style.border = '2px solid #28a745';
                    item.style.cursor = 'pointer';
                    item.title = 'Click to view processed results';
                }
                galleryGrid.appendChild(item);
            });
        }
        
        // Update "Load More" button visibility and text
        function updateLoadMoreButton() {
            let loadMoreBtn = document.getElementById('load-more-btn');
            
            // If all groups are displayed, remove button
            if (displayedGroups >= allGroups.length) {
                if (loadMoreBtn) {
                    loadMoreBtn.remove();
                }
                return;
            }
            
            // Create button if it doesn't exist
            if (!loadMoreBtn) {
                loadMoreBtn = document.createElement('button');
                loadMoreBtn.id = 'load-more-btn';
                loadMoreBtn.className = 'load-more-btn';
                loadMoreBtn.textContent = 'Load More Images';
                loadMoreBtn.style.cssText = `
                    display: block;
                    margin: 2rem auto;
                    padding: 0.75rem 2rem;
                    font-size: 1rem;
                    background: var(--primary-color);
                    color: white;
                    border: none;
                    border-radius: 0.5rem;
                    cursor: pointer;
                    transition: background 0.2s;
                `;
                loadMoreBtn.onmouseover = () => loadMoreBtn.style.background = 'var(--primary-hover)';
                loadMoreBtn.onmouseout = () => loadMoreBtn.style.background = 'var(--primary-color)';
                loadMoreBtn.onclick = () => {
                    loadMoreBtn.textContent = 'Loading...';
                    loadMoreBtn.disabled = true;
                    renderGroups();
                    loadMoreBtn.disabled = false;
                    loadMoreBtn.textContent = 'Load More Images';
                };
                
                const galleryContainer = document.querySelector('.gallery-container');
                if (galleryContainer) {
                    galleryContainer.appendChild(loadMoreBtn);
                } else {
                    const galleryGrid = document.getElementById('gallery-grid');
                    if (galleryGrid && galleryGrid.parentElement) {
                        galleryGrid.parentElement.appendChild(loadMoreBtn);
                    }
                }
            }
            
            // Update button text with remaining count
            const remaining = allGroups.length - displayedGroups;
            loadMoreBtn.textContent = `Load More (${remaining} group${remaining !== 1 ? 's' : ''} remaining)`;
        }
        
        // Load images on page load (no auth needed for GCS)
        document.addEventListener('DOMContentLoaded', () => {
            loadImages();
        });
        
        // Bulk testing functions
        window.getImageAsBase64 = async function(imgElement) {
            return new Promise((resolve) => {
                if (imgElement.complete) {
                    const canvas = document.createElement('canvas');
                    canvas.width = imgElement.naturalWidth;
                    canvas.height = imgElement.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(imgElement, 0, 0);
                    resolve(canvas.toDataURL('image/png').split(',')[1]);
                } else {
                    imgElement.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = imgElement.naturalWidth;
                        canvas.height = imgElement.naturalHeight;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(imgElement, 0, 0);
                        resolve(canvas.toDataURL('image/png').split(',')[1]);
                    };
                }
            });
        };
        
        window.detectEdges = async function(imgElement, method = 'canny', crop = false) {
            const base64 = await window.getImageAsBase64(imgElement);
            const response = await fetch(`${PYTHON_SERVICE_URL}/detect-edges`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ image: base64, method, crop })
            });
            return response.json();
        };
        
        window.processBatch = async function(imageElements, options = {}) {
            const images = await Promise.all(
                Array.from(imageElements).map(img => window.getImageAsBase64(img))
            );
            
            const response = await fetch(`${PYTHON_SERVICE_URL}/process-batch`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ images, options })
            });
            return response.json();
        };
        
        window.processGCSBatch = async function(imagePaths, bucketName, options = {}) {
            const response = await fetch(`${PYTHON_SERVICE_URL}/process-gcs-batch`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ image_paths: imagePaths, bucket: bucketName, options })
            });
            return response.json();
        };
        
        window.bulkTestGallery = async function(options = {}, groupKey = null) {
            const defaultOptions = {
                edge_detection: true,
                color_separation: true,
                grid_detection: true,
                quality_check: true,
                crop_to_content: false,
                color_method: 'lab'
            };
            
            const opts = { ...defaultOptions, ...options };
            
            // Get images - filter by group if specified
            let imageElements = document.querySelectorAll('.gallery-item img');
            
            if (groupKey) {
                // Filter to specific group
                const groupItems = document.querySelectorAll(`.gallery-item[data-group-key="${groupKey}"] img`);
                imageElements = groupItems;
            }
            
            if (imageElements.length === 0) {
                console.warn('No valid images found in gallery' + (groupKey ? ` for group: ${groupKey}` : ''));
                return { success: false, error: 'No images found' };
            }
            
            // Process up to 10 images in parallel
            const images = Array.from(imageElements).slice(0, 10);
            console.log(`Processing ${images.length} images${groupKey ? ` from group: ${groupKey}` : ''}...`);
            
            return window.processBatch(images, opts);
        };
        
        // Test specific group by key
        window.testGroup = async function(groupKey, options = {}) {
            return window.bulkTestGallery(options, groupKey);
        };
        
        window.quickBulkTest = function() {
            return window.bulkTestGallery();
        };
        
        // Copy version info function
        window.copyVersionInfo = function() {
            const versionEl = document.getElementById('app-version');
            const buildEl = document.getElementById('app-build-timestamp');
            const dateEl = document.getElementById('app-build-date');
            const sdkEl = document.getElementById('app-firebase-sdk');
            
            const version = versionEl ? versionEl.textContent : APP_VERSION;
            const build = buildEl ? buildEl.textContent : BUILD_TIMESTAMP;
            const deployed = dateEl ? dateEl.textContent : BUILD_DATE.toLocaleString();
            const firebaseSDK = sdkEl ? sdkEl.textContent : '10.7.1';
            
            const text = `Version: ${version} | Build: ${build} | Deployed: ${deployed} | Firebase SDK: ${firebaseSDK}`;
            
            navigator.clipboard.writeText(text).then(() => {
                const btn = document.getElementById('version-copy-btn');
                const container = document.getElementById('version-info-container');
                
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = '‚úì Copied!';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.classList.remove('copied');
                    }, 2000);
                }
                
                if (container) {
                    container.style.backgroundColor = '#d4edda';
                    setTimeout(() => {
                        container.style.backgroundColor = '';
                    }, 500);
                }
                
                console.log('‚úì Version info copied:', text);
            }).catch(err => {
                console.error('Copy failed:', err);
                alert('Failed to copy. Please select and copy manually.');
            });
        };
        
        // Update version info on load
        document.addEventListener('DOMContentLoaded', () => {
            const versionEl = document.getElementById('app-version');
            const buildEl = document.getElementById('app-build-timestamp');
            const dateEl = document.getElementById('app-build-date');
            
            if (versionEl) versionEl.textContent = APP_VERSION;
            if (buildEl) buildEl.textContent = BUILD_TIMESTAMP;
            if (dateEl) dateEl.textContent = BUILD_DATE.toLocaleString();
        });
        
        // Process group of images
        window.processGroup = async function(groupKey) {
            const group = allGroups.find(g => g.key === groupKey);
            if (!group) {
                console.error('Group not found:', groupKey);
                return;
            }
            
            // Mark as processing
            processingGroups.add(groupKey);
            updateProcessButton(groupKey, true);
            
            // Create progress indicator
            const progressContainer = createProgressIndicator(groupKey, group.images.length);
            
            try {
                // Get image paths from group - need to handle different buckets per image
                const imageRequests = group.images.map(img => ({
                    path: img.path || img.name,
                    bucket: img.bucket || GCS_BUCKETS[0],
                    name: img.name
                }));
                
                // Group by bucket for batch processing
                const bucketGroups = {};
                imageRequests.forEach(req => {
                    const bucket = req.bucket;
                    if (!bucketGroups[bucket]) {
                        bucketGroups[bucket] = [];
                    }
                    bucketGroups[bucket].push(req);
                });
                
                // Process each bucket group separately
                const allResults = [];
                let processedCount = 0;
                
                console.log(`Processing group ${groupKey} with ${imageRequests.length} images across ${Object.keys(bucketGroups).length} bucket(s)`);
                
                for (const [bucketName, requests] of Object.entries(bucketGroups)) {
                    const imagePaths = requests.map(r => r.path);
                    console.log(`Processing ${imagePaths.length} images from bucket: ${bucketName}`);
                    
                    updateProgress(progressContainer, processedCount, imageRequests.length, `Processing ${bucketName}...`);
                    
                    // Call process-gcs-batch endpoint for this bucket
                    const response = await fetch(`${PYTHON_SERVICE_URL}/process-gcs-batch`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            image_paths: imagePaths, 
                            bucket: bucketName, 
                            options: {
                                edge_detection: true,
                                color_separation: true,
                                grid_detection: true,
                                quality_check: true,
                                crop_to_content: false,
                                color_method: 'lab'
                            }
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText} for bucket ${bucketName}`);
                    }
                    
                    const bucketData = await response.json();
                    console.log(`Backend response for ${bucketName}:`, bucketData);
                    
                    if (bucketData.success && bucketData.results) {
                        // Add bucket info to each result
                        bucketData.results.forEach((result, idx) => {
                            if (idx < requests.length) {
                                result.bucket = bucketName;
                                result.original_name = requests[idx].name;
                            }
                        });
                        allResults.push(...bucketData.results);
                    }
                    
                    processedCount += imagePaths.length;
                }
                
                // Combine all results into single response format
                const data = {
                    success: true,
                    results: allResults,
                    count: allResults.length
                };
                
                console.log('Combined backend response:', data);
                
                if (data.success) {
                    // Filter to only successful results
                    const successfulResults = (data.results || []).filter(r => r.success === true);
                    const failedResults = (data.results || []).filter(r => r.success === false);
                    
                    console.log(`Results: ${successfulResults.length} succeeded, ${failedResults.length} failed`);
                    if (failedResults.length > 0) {
                        console.log('Failed results:', failedResults.slice(0, 3).map(r => ({ path: r.path, error: r.error })));
                    }
                    
                    // Update progress: Complete
                    updateProgress(progressContainer, imageRequests.length, imageRequests.length, 
                        successfulResults.length > 0 ? 
                        `Complete! ${successfulResults.length} succeeded, ${failedResults.length} failed` : 
                        `Failed! All ${failedResults.length} images failed`);
                    
                    // Process and store results with proper structure (only successful ones)
                    const processedResults = successfulResults.map(result => {
                        // Ensure each result has the structure needed for comparison modal
                        const imagePath = result.path || result.name || '';
                        const bucket = result.bucket || bucketName || GCS_BUCKETS[0];
                        
                        // Get processed image - check for base64 first, then URL
                        let processedImageUrl = '';
                        if (result.processed_image) {
                            processedImageUrl = `data:image/png;base64,${result.processed_image}`;
                        } else if (result.processed_url) {
                            processedImageUrl = result.processed_url;
                        } else {
                            processedImageUrl = result.original_url || (imagePath ? `https://storage.googleapis.com/${bucket}/${imagePath}` : '');
                        }
                        
                        return {
                            name: result.name || imagePath.split('/').pop() || 'unknown',
                            original_name: result.name || imagePath.split('/').pop() || 'unknown',
                            original_url: result.original_url || (imagePath ? `https://storage.googleapis.com/${bucket}/${imagePath}` : ''),
                            processed_url: processedImageUrl,
                            processed_image_base64: result.processed_image || null,
                            path: imagePath,
                            bucket: bucket,
                            metrics: result.metrics || {},
                            steps: result.steps || {},
                            analysis: result.analysis || {},
                            success: result.success !== false,
                            // Store the full result for debugging
                            _raw: result
                        };
                    });
                    
                    // Only mark as processed if we have successful results
                    if (processedResults.length > 0) {
                        // Store processed results
                        processedImages.set(groupKey, {
                            images: processedResults,
                            subImages: {}
                        });
                        
                        // Update UI
                        updateProcessButton(groupKey, false, true);
                        updateGroupDropdown(); // Update dropdown status
                        console.log(`‚úì Processed group ${groupKey} with ${processedResults.length} successful results`, processedResults);
                        
                        // Show success notification with view button
                        showProcessingCompleteNotification(groupKey, processedResults.length, failedResults.length);
                        
                        // Auto-open comparison modal if we have successful results
                        setTimeout(() => {
                            openComparisonModal(groupKey, processedResults[0].original_name || processedResults[0].name);
                        }, 1000);
                    } else {
                        // All failed - don't mark as processed, show error notification
                        console.warn(`All images failed for group ${groupKey}. Failed results:`, failedResults);
                        updateProcessButton(groupKey, false, false);
                        showProcessingErrorNotification(groupKey, failedResults);
                    }
                    
                    // Remove progress indicator after a delay
                    setTimeout(() => {
                        if (progressContainer && progressContainer.parentNode) {
                            progressContainer.parentNode.removeChild(progressContainer);
                        }
                    }, 2000);
                    
                    // Re-render the group header to show processed status
                    const groupHeader = document.querySelector(`.gallery-group-header[data-group-key="${groupKey}"]`);
                    if (groupHeader) {
                        const group = allGroups.find(g => g.key === groupKey);
                        if (group) {
                            // Update the header to show processed status
                            const processedBadge = groupHeader.querySelector('h2 span');
                            if (!processedBadge) {
                                const h2 = groupHeader.querySelector('h2');
                                if (h2) {
                                    h2.innerHTML += ' <span style="color: green; font-size: 0.875rem;">‚úì Processed</span>';
                                }
                            }
                            // Add view results and reset buttons if not present
                            const buttonContainer = groupHeader.querySelector('div[style*="display: flex"]');
                            if (buttonContainer) {
                                if (!buttonContainer.querySelector('.view-results-btn')) {
                                    const viewBtn = document.createElement('button');
                                    viewBtn.className = 'view-results-btn';
                                    viewBtn.dataset.groupKey = groupKey;
                                    viewBtn.onclick = () => viewProcessedResults(groupKey);
                                    viewBtn.style.cssText = 'padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;';
                                    viewBtn.textContent = 'üëÅÔ∏è View Results';
                                    viewBtn.title = 'View processed results';
                                    buttonContainer.insertBefore(viewBtn, buttonContainer.firstChild);
                                }
                                if (!buttonContainer.querySelector('.reset-group-btn')) {
                                    const resetBtn = document.createElement('button');
                                    resetBtn.className = 'reset-group-btn';
                                    resetBtn.dataset.groupKey = groupKey;
                                    resetBtn.onclick = () => resetGroupProcessing(groupKey);
                                    resetBtn.style.cssText = 'padding: 0.5rem 1rem; background: #6c757d; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;';
                                    resetBtn.textContent = 'üîÑ Reset';
                                    resetBtn.title = 'Reset processing status';
                                    buttonContainer.insertBefore(resetBtn, buttonContainer.firstChild);
                                }
                            }
                        }
                    }
                } else {
                    throw new Error(data.error || 'Processing failed');
                }
            } catch (error) {
                console.error('Error processing group:', error);
                updateProgress(progressContainer, 0, group.images.length, `Error: ${error.message}`);
                alert(`Failed to process group: ${error.message}`);
                updateProcessButton(groupKey, false, false);
                
                // Remove progress indicator after error
                setTimeout(() => {
                    if (progressContainer && progressContainer.parentNode) {
                        progressContainer.parentNode.removeChild(progressContainer);
                    }
                }, 5000);
            } finally {
                processingGroups.delete(groupKey);
            }
        };
        
        // Create progress indicator element
        function createProgressIndicator(groupKey, totalImages) {
            const groupHeader = document.querySelector(`.gallery-group-header`);
            if (!groupHeader) return null;
            
            const progressDiv = document.createElement('div');
            progressDiv.id = `progress-${groupKey}`;
            progressDiv.style.cssText = `
                margin-top: 0.5rem;
                padding: 0.75rem;
                background: #f0f0f0;
                border-radius: 0.375rem;
                font-size: 0.875rem;
            `;
            
            const progressBar = document.createElement('div');
            progressBar.style.cssText = `
                width: 100%;
                height: 8px;
                background: #e0e0e0;
                border-radius: 4px;
                overflow: hidden;
                margin-top: 0.5rem;
            `;
            
            const progressFill = document.createElement('div');
            progressFill.id = `progress-fill-${groupKey}`;
            progressFill.style.cssText = `
                height: 100%;
                width: 0%;
                background: var(--primary-color);
                transition: width 0.3s ease;
            `;
            
            const progressText = document.createElement('div');
            progressText.id = `progress-text-${groupKey}`;
            progressText.textContent = `Processing 0 of ${totalImages} images...`;
            progressText.style.cssText = `
                color: var(--text-secondary);
                margin-bottom: 0.25rem;
            `;
            
            progressBar.appendChild(progressFill);
            progressDiv.appendChild(progressText);
            progressDiv.appendChild(progressBar);
            
            // Insert after group header
            groupHeader.parentNode.insertBefore(progressDiv, groupHeader.nextSibling);
            
            return progressDiv;
        }
        
        // Update progress indicator
        function updateProgress(container, current, total, status) {
            if (!container) return;
            
            const groupKey = container.id.replace('progress-', '');
            const progressFill = container.querySelector(`#progress-fill-${groupKey}`);
            const progressText = container.querySelector(`#progress-text-${groupKey}`);
            
            if (progressFill) {
                const percentage = total > 0 ? (current / total) * 100 : 0;
                progressFill.style.width = `${percentage}%`;
            }
            
            if (progressText) {
                if (status) {
                    progressText.textContent = status;
                } else {
                    progressText.textContent = `Processing ${current} of ${total} images...`;
                }
            }
        }
        
        // Show processing complete notification
        function showProcessingCompleteNotification(groupKey, resultCount, failedCount = 0) {
            // Remove any existing notification
            const existing = document.getElementById('processing-notification');
            if (existing) {
                existing.remove();
            }
            
            // Create notification
            const notification = document.createElement('div');
            notification.id = 'processing-notification';
            const bgColor = failedCount > 0 ? '#ffc107' : '#28a745';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${bgColor};
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 0.5rem;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                z-index: 10000;
                max-width: 400px;
                animation: slideIn 0.3s ease-out;
            `;
            
            const statusText = failedCount > 0 ? 
                `${resultCount} succeeded, ${failedCount} failed` : 
                `${resultCount} image(s) processed successfully`;
            
            notification.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem;">
                    <div>
                        <strong>${failedCount > 0 ? '‚ö†Ô∏è Processing Complete (Partial)' : '‚úì Processing Complete!'}</strong>
                        <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem;">
                            ${statusText}
                        </p>
                    </div>
                    ${resultCount > 0 ? `
                        <button onclick="document.getElementById('processing-notification').remove(); viewProcessedResults('${groupKey}')"
                                style="padding: 0.5rem 1rem; background: white; color: ${bgColor}; border: none; border-radius: 0.375rem; cursor: pointer; font-weight: bold; font-size: 0.875rem;">
                            View Results
                        </button>
                    ` : ''}
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => notification.remove(), 300);
                }
            }, 10000);
        }
        
        // Show processing error notification
        function showProcessingErrorNotification(groupKey, failedResults) {
            // Remove any existing notification
            const existing = document.getElementById('processing-notification');
            if (existing) {
                existing.remove();
            }
            
            // Create error notification
            const notification = document.createElement('div');
            notification.id = 'processing-notification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #dc3545;
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 0.5rem;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                z-index: 10000;
                max-width: 500px;
                animation: slideIn 0.3s ease-out;
            `;
            
            const errorSummary = failedResults.slice(0, 3).map(r => r.error || 'Unknown error').join(', ');
            const moreErrors = failedResults.length > 3 ? ` and ${failedResults.length - 3} more` : '';
            
            notification.innerHTML = `
                <div>
                    <strong>‚ùå Processing Failed</strong>
                    <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem;">
                        All ${failedResults.length} image(s) failed to process.
                    </p>
                    <details style="margin-top: 0.5rem; font-size: 0.75rem; opacity: 0.9;">
                        <summary style="cursor: pointer;">View errors</summary>
                        <div style="margin-top: 0.5rem; max-height: 200px; overflow-y: auto;">
                            ${errorSummary}${moreErrors}
                        </div>
                    </details>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 15 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => notification.remove(), 300);
                }
            }, 15000);
        }
        
        // Add CSS animations for notification
        if (!document.getElementById('notification-styles')) {
            const style = document.createElement('style');
            style.id = 'notification-styles';
            style.textContent = `
                @keyframes slideIn {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                @keyframes slideOut {
                    from {
                        transform: translateX(0);
                        opacity: 1;
                    }
                    to {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Process a single image
        window.processSingleImage = async function(groupKey, imagePath, imageName, bucketName) {
            const btn = document.querySelector(`.process-single-image-btn[data-image-name="${imageName}"]`);
            if (!btn) return;
            
            // Disable button and show processing
            btn.disabled = true;
            btn.textContent = '‚è≥ Processing...';
            btn.style.background = '#ccc';
            
            try {
                console.log(`Processing single image: ${imageName} from ${bucketName}`);
                
                // Call process-gcs-batch endpoint with single image
                const response = await fetch(`${PYTHON_SERVICE_URL}/process-gcs-batch`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        image_paths: [imagePath], 
                        bucket: bucketName, 
                        options: {
                            edge_detection: true,
                            color_separation: true,
                            grid_detection: true,
                            quality_check: true,
                            crop_to_content: false,
                            color_method: 'lab'
                        }
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Single image processing response:', data);
                
                if (data.success && data.results && data.results.length > 0) {
                    const result = data.results[0];
                    
                    if (result.success) {
                        // Store result for this image
                        const processed = processedImages.get(groupKey) || { images: [], subImages: {} };
                        
                        // Check if this image is already in the list
                        const existingIndex = processed.images.findIndex(img => 
                            img.original_name === imageName || 
                            img.name === imageName ||
                            img.path === imagePath
                        );
                        
                        const processedImage = {
                            name: result.name || imageName,
                            original_name: imageName,
                            original_url: result.original_url || (imagePath ? `https://storage.googleapis.com/${bucketName}/${imagePath}` : ''),
                            processed_url: result.processed_url || result.original_url || '',
                            path: imagePath,
                            bucket: bucketName,
                            metrics: result.metrics || {},
                            steps: result.steps || {},
                            analysis: result.analysis || {},
                            success: true,
                            _raw: result
                        };
                        
                        if (existingIndex >= 0) {
                            processed.images[existingIndex] = processedImage;
                        } else {
                            processed.images.push(processedImage);
                        }
                        
                        processedImages.set(groupKey, processed);
                        
                        // Update button
                        btn.textContent = '‚úì Done';
                        btn.style.background = '#28a745';
                        
                        // Add view button
                        const buttonContainer = btn.parentElement;
                        if (!buttonContainer.querySelector('.view-single-result-btn')) {
                            const viewBtn = document.createElement('button');
                            viewBtn.className = 'view-single-result-btn';
                            viewBtn.textContent = 'üëÅÔ∏è View';
                            viewBtn.style.cssText = 'padding: 0.4rem 0.8rem; background: #28a745; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.75rem; flex: 1;';
                            viewBtn.onclick = () => viewSingleImageResult(groupKey, imageName);
                            buttonContainer.appendChild(viewBtn);
                        }
                        
                        // Update image info to show processed badge
                        const item = btn.closest('.gallery-item');
                        if (item) {
                            const infoDiv = item.querySelector('.gallery-item-info');
                            if (infoDiv && !infoDiv.querySelector('span[style*="color: green"]')) {
                                const badge = document.createElement('span');
                                badge.style.cssText = 'color: green; font-size: 0.7rem; margin-left: 0.5rem;';
                                badge.textContent = '‚úì Processed';
                                infoDiv.appendChild(badge);
                            }
                        }
                        
                        // Show success notification
                        showSingleImageSuccessNotification(imageName);
                        
                        // Auto-open comparison modal
                        setTimeout(() => {
                            viewSingleImageResult(groupKey, imageName);
                        }, 500);
                        
                        console.log(`‚úì Successfully processed single image: ${imageName}`);
                    } else {
                        throw new Error(result.error || 'Processing failed');
                    }
                } else {
                    throw new Error('No results returned or processing failed');
                }
            } catch (error) {
                console.error('Error processing single image:', error);
                btn.textContent = '‚ùå Failed';
                btn.style.background = '#dc3545';
                alert(`Failed to process image: ${error.message}`);
            } finally {
                // Re-enable button after a delay
                setTimeout(() => {
                    btn.disabled = false;
                    if (btn.textContent === '‚ùå Failed') {
                        btn.textContent = '‚ö° Process';
                        btn.style.background = 'var(--primary-color)';
                    }
                }, 3000);
            }
        };
        
        // View result for a single image
        window.viewSingleImageResult = function(groupKey, imageName) {
            const processed = processedImages.get(groupKey);
            if (!processed || !processed.images || processed.images.length === 0) {
                alert('No processed results available for this image.');
                return;
            }
            
            // Find the specific image
            const processedImage = processed.images.find(img => 
                img.original_name === imageName || 
                img.name === imageName
            );
            
            if (processedImage) {
                // Create a temporary single-item array for the modal
                const tempProcessed = {
                    images: [processedImage],
                    subImages: {}
                };
                
                // Temporarily store it
                const originalProcessed = processedImages.get(groupKey);
                processedImages.set(groupKey, tempProcessed);
                
                // Open modal
                openComparisonModal(groupKey, imageName);
                
                // Restore original after a moment (in case modal needs it)
                setTimeout(() => {
                    if (originalProcessed) {
                        processedImages.set(groupKey, originalProcessed);
                    }
                }, 100);
            } else {
                alert('Processed result not found for this image.');
            }
        };
        
        // Show success notification for single image
        function showSingleImageSuccessNotification(imageName) {
            const existing = document.getElementById('single-image-notification');
            if (existing) {
                existing.remove();
            }
            
            const notification = document.createElement('div');
            notification.id = 'single-image-notification';
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 0.75rem 1rem;
                border-radius: 0.5rem;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
            `;
            notification.innerHTML = `
                <strong>‚úì Image Processed!</strong><br>
                <span style="font-size: 0.875rem;">${imageName}</span>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => notification.remove(), 300);
                }
            }, 3000);
        }
        
        // View processed results
        window.viewProcessedResults = function(groupKey) {
            const processed = processedImages.get(groupKey);
            if (!processed || !processed.images || processed.images.length === 0) {
                alert('No processed results available. Please process the group first.');
                return;
            }
            
            // Remove notification if still visible
            const notification = document.getElementById('processing-notification');
            if (notification) {
                notification.remove();
            }
            
            openComparisonModal(groupKey, processed.images[0].original_name || processed.images[0].name);
        };
        
        // Update process button state
        function updateProcessButton(groupKey, isProcessing, isProcessed = false) {
            const btn = document.querySelector(`.process-group-btn[data-group-key="${groupKey}"]`);
            if (btn) {
                btn.disabled = isProcessing;
                btn.textContent = isProcessing ? '‚è≥ Processing...' : (isProcessed ? 'üîÑ Reprocess' : '‚ö° Process');
                btn.style.background = isProcessing ? '#ccc' : 'var(--primary-color)';
                btn.style.cursor = isProcessing ? 'not-allowed' : 'pointer';
            }
            
            // Also update the group header status badge
            const groupHeader = document.querySelector(`.gallery-group-header[data-group-key="${groupKey}"]`);
            if (groupHeader) {
                const h2 = groupHeader.querySelector('h2');
                if (h2) {
                    // Remove existing status badges
                    h2.innerHTML = h2.innerHTML.replace(/ <span style="color: (green|orange)[^>]*>(‚úì Processed|‚è≥ Processing)<\/span>/, '');
                    
                    // Add new status badge
                    if (isProcessing) {
                        h2.innerHTML += ' <span style="color: orange; font-size: 0.875rem;">‚è≥ Processing</span>';
                    } else if (isProcessed) {
                        h2.innerHTML += ' <span style="color: green; font-size: 0.875rem;">‚úì Processed</span>';
                    }
                }
            }
        }
        
        // Comparison modal state
        let currentComparisonGroup = null;
        let currentComparisonImages = [];
        let currentComparisonIndex = 0;
        let currentComparisonMetrics = {};
        // Open comparison modal
        window.openComparisonModal = function(groupKey, imageName) {
            console.log('Opening comparison modal for:', groupKey, imageName);
            const processed = processedImages.get(groupKey);
            if (!processed || !processed.images || processed.images.length === 0) {
                alert('No processed images available. Please process the group first.');
                console.warn('No processed images found for group:', groupKey, 'Available groups:', Array.from(processedImages.keys()));
                return;
            }
            
            console.log('Found processed images:', processed.images.length, processed.images);
            
            currentComparisonGroup = groupKey;
            currentComparisonImages = processed.images;
            currentComparisonIndex = 0;
            
            const modal = document.getElementById('comparison-modal');
            if (!modal) {
                console.error('Comparison modal element not found!');
                alert('Comparison modal not found. Please refresh the page.');
                return;
            }
            
            modal.style.display = 'block';
            modal.style.zIndex = '10000';
            
            // Set initial view mode
            switchViewMode('side-by-side');
            
            // Find image index
            const imageIndex = currentComparisonImages.findIndex(img => 
                img.name === imageName || 
                img.original_name === imageName ||
                img.path === imageName ||
                (img.path && img.path.includes(imageName))
            );
            if (imageIndex >= 0) {
                currentComparisonIndex = imageIndex;
                console.log('Found image at index:', imageIndex);
            } else {
                console.log('Image not found in processed results, using first image. Looking for:', imageName);
                console.log('Available images:', currentComparisonImages.map(img => img.name || img.original_name || img.path));
            }
            
            renderComparison();
        };
        
        // Close comparison modal
        window.closeComparisonModal = function() {
            const modal = document.getElementById('comparison-modal');
            modal.style.display = 'none';
            currentComparisonGroup = null;
            currentComparisonImages = [];
            currentComparisonIndex = 0;
        };
        
        // Navigate images in comparison modal
        window.navigateImage = function(direction) {
            if (currentComparisonImages.length === 0) return;
            
            currentComparisonIndex += direction;
            if (currentComparisonIndex < 0) {
                currentComparisonIndex = currentComparisonImages.length - 1;
            } else if (currentComparisonIndex >= currentComparisonImages.length) {
                currentComparisonIndex = 0;
            }
            
            renderComparison();
        };
        
        // Render comparison view
        function renderComparison() {
            if (currentComparisonImages.length === 0) return;
            
            const current = currentComparisonImages[currentComparisonIndex];
            
            // Find the base image (-0001) for ground truth
            // Extract the prefix (e.g., "1006427285" from "1006427285-0003.png")
            let baseImageName = null;
            let groundTruthUrl = null;
            
            if (current.original_name || current.name) {
                const currentName = current.original_name || current.name;
                const match = currentName.match(/^(\d+)-/);
                if (match) {
                    const prefix = match[1];
                    baseImageName = `${prefix}-0001.png`;
                    
                    // Try to find the base image in the group
                    const group = allGroups.find(g => g.key === currentComparisonGroup);
                    if (group) {
                        const baseImage = group.images.find(img => img.name === baseImageName || img.name.includes('-0001'));
                        if (baseImage) {
                            groundTruthUrl = baseImage.url || (baseImage.path ? `https://storage.googleapis.com/${baseImage.bucket || GCS_BUCKETS[0]}/${baseImage.path}` : null);
                        }
                    }
                    
                    // If not found in group, construct URL
                    if (!groundTruthUrl && current.bucket) {
                        const basePath = current.path ? current.path.replace(currentName, baseImageName) : `kaggle-data/physionet-ecg/train/${baseImageName}`;
                        groundTruthUrl = `https://storage.googleapis.com/${current.bucket}/${basePath}`;
                    }
                }
            }
            
            // Get original (unprocessed) image URL (the current image being processed)
            const originalUrl = current.original_url || (current.path ? `https://storage.googleapis.com/${current.bucket || GCS_BUCKETS[0]}/${current.path}` : '');
            const originalName = current.original_name || current.name || 'Original';
            
            // Get processed image URL - prefer base64 if available
            let processedUrl = originalUrl;
            if (current.processed_image_base64) {
                processedUrl = `data:image/png;base64,${current.processed_image_base64}`;
            } else if (current.processed_url && current.processed_url !== originalUrl) {
                processedUrl = current.processed_url;
            }
            
            // Update all three panels in correct order: Original ‚Üí Ground Truth ‚Üí Processed
            // Panel 1: Original (raw input - unprocessed current image)
            const originalImg = document.getElementById('comparison-original');
            const originalNameEl = document.getElementById('comparison-original-name');
            if (originalImg) {
                originalImg.src = originalUrl || '';
                // Auto-apply overlays when image loads
                originalImg.onload = () => {
                    const showEdges = document.getElementById('toggle-edges')?.checked || false;
                    const showGrid = document.getElementById('toggle-grid')?.checked || false;
                    const showSmudges = document.getElementById('toggle-smudges')?.checked || false;
                    if (showEdges || showGrid || showSmudges) {
                        applyOverlaysToImage(originalImg, showEdges, showSmudges, showGrid, 'original');
                    }
                };
            }
            if (originalNameEl) {
                originalNameEl.textContent = originalName || 'Original (Raw Input)';
            }
            
            // Panel 2: Ground Truth (reference -0001 image)
            const groundTruthImg = document.getElementById('comparison-ground-truth');
            const groundTruthName = document.getElementById('comparison-ground-truth-name');
            if (groundTruthImg) {
                groundTruthImg.src = groundTruthUrl || originalUrl || '';
                // Auto-apply overlays when image loads
                groundTruthImg.onload = () => {
                    const showEdges = document.getElementById('toggle-edges')?.checked || false;
                    const showGrid = document.getElementById('toggle-grid')?.checked || false;
                    const showSmudges = document.getElementById('toggle-smudges')?.checked || false;
                    if (showEdges || showGrid || showSmudges) {
                        applyOverlaysToImage(groundTruthImg, showEdges, showSmudges, showGrid, 'ground-truth');
                    }
                };
            }
            if (groundTruthName) {
                groundTruthName.textContent = baseImageName || 'Ground Truth (Reference)';
            }
            
            // Panel 3: Processed (final result)
            const processedImg = document.getElementById('comparison-processed');
            const processedNameEl = document.getElementById('comparison-processed-name');
            if (processedImg) {
                // Use processed image if available, otherwise show original
                if (processedUrl && processedUrl !== originalUrl) {
                    processedImg.src = processedUrl;
                } else {
                    processedImg.src = originalUrl || '';
                }
                // Auto-apply overlays when image loads
                processedImg.onload = () => {
                    const showEdges = document.getElementById('toggle-edges')?.checked || false;
                    const showGrid = document.getElementById('toggle-grid')?.checked || false;
                    const showSmudges = document.getElementById('toggle-smudges')?.checked || false;
                    if (showEdges || showGrid || showSmudges) {
                        applyOverlaysToImage(processedImg, showEdges, showSmudges, showGrid, 'processed');
                    }
                };
            }
            if (processedNameEl) {
                if (processedUrl && processedUrl !== originalUrl) {
                    processedNameEl.textContent = originalName + ' (Processed)';
                } else {
                    processedNameEl.textContent = originalName + ' (Not Processed Yet)';
                }
            }
            
            // Update fade comparison images (View 2: Ground Truth vs Processed)
            const fadeOriginal = document.getElementById('fade-original');
            const fadeProcessed = document.getElementById('fade-processed');
            const fadeContainer = document.querySelector('.fade-comparison-container');
            
            if (fadeOriginal) {
                // Use ground truth for fade comparison
                fadeOriginal.src = groundTruthUrl || originalUrl;
            }
            if (fadeProcessed) {
                // Check if processed image is different from original
                if (processedUrl && processedUrl !== originalUrl) {
                    fadeProcessed.src = processedUrl;
                    fadeProcessed.style.opacity = '0.5';
                    fadeProcessed.style.display = 'block';
                    if (fadeContainer) {
                        fadeContainer.style.display = 'block';
                        // Remove warning if it exists
                        const warning = fadeContainer.querySelector('.fade-warning');
                        if (warning) warning.remove();
                    }
                } else {
                    // No processed image available yet - show warning
                    fadeProcessed.style.display = 'none';
                    if (fadeContainer) {
                        fadeContainer.style.display = 'block';
                        const warningMsg = fadeContainer.querySelector('.fade-warning');
                        if (!warningMsg) {
                            const warning = document.createElement('div');
                            warning.className = 'fade-warning';
                            warning.style.cssText = 'padding: 1rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 0.5rem; color: #856404; margin-top: 1rem;';
                            warning.innerHTML = '<strong>‚ÑπÔ∏è Note:</strong> Processed image not available yet. Click "‚ö° Process Image" button to generate the transformed version for comparison.';
                            fadeContainer.appendChild(warning);
                        }
                    }
                }
            }
            
            // Reset slider to middle
            const fadeSlider = document.getElementById('fade-slider');
            if (fadeSlider) {
                fadeSlider.value = 50;
                updateFadePercentage(50);
            }
            
            // Update processing stages
            renderProcessingStages(current);
            
            // Update processing checklist if step-by-step view is active
            if (currentViewMode === 'step-by-step') {
                renderProcessingChecklist(current);
            }
            
            // Update metrics - check both current.metrics and _raw.metrics
            const metrics = current.metrics || current._raw?.metrics || {};
            console.log('Metrics data:', metrics, 'Current object:', current);
            
            const snrTraceEl = document.getElementById('metric-snr-trace');
            const snrEl = document.getElementById('metric-snr');
            const typeEl = document.getElementById('metric-type');
            const contrastEl = document.getElementById('metric-contrast');
            const smudgesEl = document.getElementById('metric-smudges');
            
            // SNR for ECG trace only (not grid)
            if (snrTraceEl) {
                if (metrics.snr_trace_db !== undefined && metrics.snr_trace_db !== null) {
                    snrTraceEl.textContent = metrics.snr_trace_db.toFixed(2);
                } else if (metrics.snr_db !== undefined && metrics.snr_db !== null) {
                    // Fallback to overall SNR if trace-specific not available
                    snrTraceEl.textContent = metrics.snr_db.toFixed(2) + ' (overall)';
                } else {
                    snrTraceEl.textContent = '--';
                }
            }
            
            // Overall SNR
            if (snrEl) {
                if (metrics.snr_db !== undefined && metrics.snr_db !== null) {
                    snrEl.textContent = metrics.snr_db.toFixed(2);
                } else {
                    snrEl.textContent = '--';
                }
            }
            
            if (typeEl) {
                typeEl.textContent = metrics.image_type || '--';
            }
            
            if (contrastEl) {
                if (metrics.contrast !== undefined && metrics.contrast !== null) {
                    contrastEl.textContent = metrics.contrast.toFixed(2);
                } else if (metrics.contrast_std !== undefined && metrics.contrast_std !== null) {
                    contrastEl.textContent = metrics.contrast_std.toFixed(2);
                } else {
                    contrastEl.textContent = '--';
                }
            }
            
            if (smudgesEl) {
                if (metrics.smudges) {
                    if (typeof metrics.smudges === 'string') {
                        smudgesEl.textContent = metrics.smudges;
                    } else if (metrics.smudges.qualitative) {
                        smudgesEl.textContent = metrics.smudges.qualitative;
                    } else if (metrics.smudges.smudge_count !== undefined) {
                        smudgesEl.textContent = `${metrics.smudges.smudge_count} smudges`;
                    } else {
                        smudgesEl.textContent = 'Detected';
                    }
                } else {
                    smudgesEl.textContent = '--';
                }
            }
            
            // Update thumbnails
            renderThumbnails();
            
            // Update step-by-step view
            updateStepByStepView(current);
        }
        
        // View mode switching
        let currentViewMode = 'side-by-side';
        window.switchViewMode = function(mode) {
            currentViewMode = mode;
            
            // Hide all views
            document.querySelectorAll('.view-container').forEach(view => {
                view.style.display = 'none';
            });
            
            // Show selected view
            const selectedView = document.getElementById(`view-${mode}`);
            if (selectedView) {
                selectedView.style.display = 'block';
            }
            
            // If switching to step-by-step view, render the checklist
            if (mode === 'step-by-step') {
                const current = currentComparisonImages[currentComparisonIndex];
                if (current) {
                    renderProcessingChecklist(current);
                }
            }
            
            // Update button styles
            document.querySelectorAll('.view-mode-btn').forEach(btn => {
                if (btn.dataset.view === mode) {
                    btn.style.background = 'var(--primary-color)';
                    btn.classList.add('active');
                } else {
                    btn.style.background = '#6c757d';
                    btn.classList.remove('active');
                }
            });
        };
        
        // Step-by-step navigation
        let currentStepIndex = 0;
        let stepImages = [];
        
        function updateStepByStepView(current) {
            // Build step images array from processing steps
            stepImages = [];
            
            // Step 0: Original
            if (current.original_url) {
                stepImages.push({
                    image: current.original_url,
                    name: 'Original Image',
                    description: 'The original ECG image before any processing.'
                });
            }
            
            // Add steps from processing pipeline
            if (current.steps) {
                if (current.steps.image_loading && current.steps.image_loading.image_loaded) {
                    stepImages.push({
                        image: current.original_url,
                        name: 'Image Loaded',
                        description: 'Image successfully loaded and ready for processing.'
                    });
                }
                
                if (current.steps.quality_gates) {
                    stepImages.push({
                        image: current.processed_url || current.original_url,
                        name: 'Quality Check',
                        description: `Quality gates passed. Blur score: ${current.steps.quality_gates.blur_score?.toFixed(1) || 'N/A'}, DPI: ${current.steps.quality_gates.dpi || 'N/A'}`
                    });
                }
                
                if (current.steps.color_separation) {
                    stepImages.push({
                        image: current.processed_url || current.original_url,
                        name: 'Color Separation',
                        description: `Separated ECG trace from grid using ${current.steps.color_separation.method || 'LAB'} color space.`
                    });
                }
                
                if (current.steps.edge_detection) {
                    stepImages.push({
                        image: current.processed_url || current.original_url,
                        name: 'Edge Detection',
                        description: `Detected ${current.steps.edge_detection.edge_pixels || 0} edge pixels using Canny edge detection.`
                    });
                }
                
                if (current.steps.grid_detection) {
                    stepImages.push({
                        image: current.processed_url || current.original_url,
                        name: 'Grid Detection',
                        description: `Detected grid lines: ${current.steps.grid_detection.fine_lines || 0} fine, ${current.steps.grid_detection.bold_lines || 0} bold.`
                    });
                }
                
                if (current.steps.smudge_removal) {
                    stepImages.push({
                        image: current.processed_url || current.original_url,
                        name: 'Smudge Removal',
                        description: `Removed ${current.steps.smudge_removal.smudge_count || 0} smudges from the image.`
                    });
                }
            }
            
            // Final: Processed
            if (current.processed_url && current.processed_url !== current.original_url) {
                stepImages.push({
                    image: current.processed_url,
                    name: 'Final Processed Image',
                    description: 'The final processed image after all transformations.'
                });
            }
            
            // Reset to first step
            currentStepIndex = 0;
            navigateStep(0);
        }
        
        window.navigateStep = function(direction) {
            if (stepImages.length === 0) return;
            
            currentStepIndex += direction;
            if (currentStepIndex < 0) currentStepIndex = stepImages.length - 1;
            if (currentStepIndex >= stepImages.length) currentStepIndex = 0;
            
            const step = stepImages[currentStepIndex];
            const stepImage = document.getElementById('step-image');
            const stepInfo = document.getElementById('step-info');
            const stepDesc = document.getElementById('step-description');
            
            if (stepImage) stepImage.src = step.image;
            if (stepInfo) stepInfo.textContent = `Step ${currentStepIndex + 1} of ${stepImages.length}: ${step.name}`;
            if (stepDesc) stepDesc.innerHTML = `<p style="margin: 0; color: #666; font-weight: 500;">${step.description}</p>`;
            
            // Update button states
            const stepPrev = document.getElementById('step-prev');
            const stepNext = document.getElementById('step-next');
            if (stepPrev) stepPrev.disabled = stepImages.length <= 1;
            if (stepNext) stepNext.disabled = stepImages.length <= 1;
        };
        
        // Processing steps definition
        const PROCESSING_STEPS = [
            { id: 0, name: 'Assumptions', step_id: 0, method_id: 'default', icon: 'üìã' },
            { id: 1, name: 'Quality Gates', step_id: 1, method_id: 'default', icon: '‚úÖ' },
            { id: 2, name: 'Color Separation', step_id: 2, method_id: 'lab', icon: 'üé®' },
            { id: 3, name: 'Illumination Normalization', step_id: 3, method_id: 'clahe', icon: 'üí°' },
            { id: 4, name: 'Multi-Scale Grid Detection', step_id: 4, method_id: 'default', icon: 'üìê' },
            { id: 5, name: 'Smudge Removal', step_id: 5, method_id: 'inpainting', icon: 'üßπ' },
            { id: 6, name: 'Rotation Correction', step_id: 6, method_id: 'hough', icon: 'üîÑ' },
            { id: 7, name: 'FFT Grid Reconstruction', step_id: 7, method_id: 'default', icon: 'üìä' },
            { id: 8, name: 'Grid Line Detection', step_id: 8, method_id: 'hough', icon: 'üìè' },
            { id: 9, name: 'Grid Spacing Estimation', step_id: 9, method_id: 'default', icon: 'üìè' },
            { id: 10, name: 'Affine Transform', step_id: 10, method_id: 'default', icon: 'üîÄ' },
            { id: 11, name: 'ECG Trace Extraction', step_id: 11, method_id: 'default', icon: 'üìà' },
            { id: 12, name: 'Apply Transform to Trace', step_id: 12, method_id: 'default', icon: '‚û°Ô∏è' },
            { id: 13, name: 'Skeletonize', step_id: 13, method_id: 'default', icon: 'ü¶¥' },
            { id: 14, name: 'Trace to Signal', step_id: 14, method_id: 'default', icon: 'üìâ' },
            { id: 15, name: 'Post-Process Signal', step_id: 15, method_id: 'default', icon: '‚ú®' }
        ];
        
        let currentSelectedStep = null;
        let stepResults = {}; // Store results for each step
        
        // Render interactive processing checklist
        function renderProcessingChecklist(current) {
            const checklist = document.getElementById('processing-checklist');
            if (!checklist) return;
            
            // If no current image or no processing done, show all steps as pending
            if (!current || (!current.steps && !current.processed_url)) {
                checklist.innerHTML = `
                    <div style="padding: 1rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 0.5rem; color: #856404; margin-bottom: 1rem;">
                        <strong>‚ÑπÔ∏è No processing data available.</strong><br>
                        <span style="font-size: 0.875rem;">Process the image first to see step-by-step transformations. Click "‚ö° Process" button on the group header.</span>
                    </div>
                ` + PROCESSING_STEPS.map((step, index) => {
                    return `
                        <div class="processing-step-item" 
                             data-step-id="${step.step_id}" 
                             data-step-index="${index}"
                             onclick="viewStepDetails(${step.step_id}, ${index})"
                             style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: white; border-radius: 0.5rem; border: 2px solid #6c757d; cursor: pointer; opacity: 0.6;">
                            <div style="font-size: 1.5rem;">${step.icon}</div>
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                                    <span style="color: #6c757d; font-weight: bold; font-size: 1.2rem;">‚óã</span>
                                    <strong style="font-size: 0.95rem;">${step.name}</strong>
                                </div>
                                <div style="font-size: 0.75rem; color: #666;">
                                    Not executed yet
                                </div>
                            </div>
                            <button onclick="event.stopPropagation(); reExecuteStep(${step.step_id}, ${index})" 
                                    style="padding: 0.5rem 1rem; background: var(--primary-color); color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;">
                                üîÑ Execute
                            </button>
                        </div>
                    `;
                }).join('');
                return;
            }
            
            checklist.innerHTML = PROCESSING_STEPS.map((step, index) => {
                // Check if step was executed
                const stepData = getStepData(current, step.step_id);
                const isCompleted = stepData !== null;
                const status = isCompleted ? 'completed' : 'pending';
                const statusIcon = isCompleted ? '‚úì' : '‚óã';
                const statusColor = isCompleted ? '#28a745' : '#6c757d';
                
                return `
                    <div class="processing-step-item" 
                         data-step-id="${step.step_id}" 
                         data-step-index="${index}"
                         onclick="viewStepDetails(${step.step_id}, ${index})"
                         style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: white; border-radius: 0.5rem; border: 2px solid ${statusColor}; cursor: pointer; transition: all 0.2s;"
                         onmouseover="this.style.boxShadow='0 4px 8px rgba(0,0,0,0.1)'"
                         onmouseout="this.style.boxShadow='none'">
                        <div style="font-size: 1.5rem;">${step.icon}</div>
                        <div style="flex: 1;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                                <span style="color: ${statusColor}; font-weight: bold; font-size: 1.2rem;">${statusIcon}</span>
                                <strong style="font-size: 0.95rem;">${step.name}</strong>
                            </div>
                            <div style="font-size: 0.75rem; color: #666;">
                                ${stepData ? formatStepDetails(stepData) : 'Not executed yet'}
                            </div>
                        </div>
                        <button onclick="event.stopPropagation(); reExecuteStep(${step.step_id}, ${index})" 
                                style="padding: 0.5rem 1rem; background: var(--primary-color); color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;">
                            üîÑ Re-execute
                        </button>
                    </div>
                `;
            }).join('');
        }
        
        // Get step data from current processing result
        function getStepData(current, stepId) {
            if (!current || !current.steps) return null;
            
            // Map step_id to step data keys
            const stepMap = {
                0: 'assumptions',
                1: 'quality_gates',
                2: 'color_separation',
                3: 'illumination_normalization',
                4: 'grid_detection',
                5: 'smudge_removal',
                6: 'rotation_correction',
                7: 'fft_reconstruction',
                8: 'grid_line_detection',
                9: 'grid_spacing',
                10: 'affine_transform',
                11: 'trace_extraction',
                12: 'apply_transform',
                13: 'skeletonize',
                14: 'trace_to_signal',
                15: 'post_process'
            };
            
            const stepKey = stepMap[stepId];
            return current.steps[stepKey] || null;
        }
        
        // Format step details for display
        function formatStepDetails(stepData) {
            if (!stepData) return 'No details available';
            
            const details = [];
            if (stepData.edge_pixels !== undefined) {
                details.push(`${stepData.edge_pixels} edge pixels`);
            }
            if (stepData.fine_lines !== undefined && stepData.bold_lines !== undefined) {
                details.push(`${stepData.fine_lines} fine, ${stepData.bold_lines} bold lines`);
            }
            if (stepData.blur_score !== undefined) {
                details.push(`Blur: ${stepData.blur_score.toFixed(1)}`);
            }
            if (stepData.dpi !== undefined) {
                details.push(`DPI: ${stepData.dpi}`);
            }
            if (stepData.method) {
                details.push(`Method: ${stepData.method}`);
            }
            if (stepData.smudge_count !== undefined) {
                details.push(`${stepData.smudge_count} smudges removed`);
            }
            
            return details.length > 0 ? details.join(', ') : 'Completed';
        }
        
        // View step details
        window.viewStepDetails = function(stepId, stepIndex) {
            const current = currentComparisonImages[currentComparisonIndex];
            if (!current) return;
            
            currentSelectedStep = { stepId, stepIndex };
            const step = PROCESSING_STEPS[stepIndex];
            const stepData = getStepData(current, stepId);
            
            const viewer = document.getElementById('step-detail-viewer');
            const title = document.getElementById('step-detail-title');
            const beforeImg = document.getElementById('step-before-image');
            const afterImg = document.getElementById('step-after-image');
            const metricsContent = document.getElementById('step-metrics-content');
            
            if (!viewer || !title) return;
            
            // Show viewer
            viewer.style.display = 'block';
            
            // Update title
            title.textContent = `${step.icon} ${step.name}`;
            
            // Set before image (original or previous step result)
            const originalUrl = current.original_url || (current.path ? `https://storage.googleapis.com/${current.bucket || GCS_BUCKETS[0]}/${current.path}` : '');
            if (beforeImg) {
                beforeImg.src = originalUrl;
            }
            
            // Set after image (current step result or processed image)
            let afterUrl = originalUrl;
            
            // Special handling for color separation - show separated images
            const imagesContainer = document.getElementById('step-images-container');
            const afterLabel = document.getElementById('step-after-label');
            
            if (stepId === 2 && stepData) {
                // Color separation step - show trace_image (ECG trace only)
                const traceImageBase64 = stepData.trace_image_base64 || stepData.output_image_base64;
                
                if (traceImageBase64) {
                    afterUrl = `data:image/png;base64,${traceImageBase64}`;
                    if (afterLabel) {
                        afterLabel.textContent = 'ECG Trace Only (After Separation)';
                    }
                }
                
                // Update layout to show 3 images if we have grid mask
                if (stepData.grid_mask_base64 || stepData.grid_mask) {
                    if (imagesContainer) {
                        imagesContainer.style.gridTemplateColumns = '1fr 1fr 1fr';
                        
                        // Add grid image panel
                        let gridPanel = document.getElementById('step-grid-image-panel');
                        if (!gridPanel) {
                            gridPanel = document.createElement('div');
                            gridPanel.id = 'step-grid-image-panel';
                            imagesContainer.appendChild(gridPanel);
                        }
                        
                        // For grid mask, we'd need to convert it to an image
                        // For now, show a placeholder or use the original with grid overlay
                        gridPanel.innerHTML = `
                            <h5 style="margin: 0 0 0.5rem 0; color: #666; font-size: 0.875rem;">Grid Only</h5>
                            <div style="border: 1px solid #ddd; border-radius: 0.5rem; overflow: hidden; background: #f8f9fa; padding: 1rem; text-align: center; color: #666;">
                                <p style="margin: 0; font-size: 0.875rem;">Grid mask detected. Grid pixels: ${stepData.grid_pixels || stepData.metrics?.grid_pixels || 'N/A'}</p>
                            </div>
                        `;
                    }
                } else {
                    // Reset to 2 columns if no grid image
                    if (imagesContainer) {
                        imagesContainer.style.gridTemplateColumns = '1fr 1fr';
                        const gridPanel = document.getElementById('step-grid-image-panel');
                        if (gridPanel) gridPanel.remove();
                    }
                }
            } else {
                // Reset layout for other steps
                if (imagesContainer) {
                    imagesContainer.style.gridTemplateColumns = '1fr 1fr';
                    const gridPanel = document.getElementById('step-grid-image-panel');
                    if (gridPanel) gridPanel.remove();
                }
                if (afterLabel) {
                    afterLabel.textContent = 'After';
                }
            }
            
            if (stepData && stepData.output_image_base64) {
                afterUrl = `data:image/png;base64,${stepData.output_image_base64}`;
            } else if (current.processed_image_base64) {
                afterUrl = `data:image/png;base64,${current.processed_image_base64}`;
            } else if (current.processed_url && current.processed_url !== originalUrl) {
                afterUrl = current.processed_url;
            }
            
            if (afterImg) {
                afterImg.src = afterUrl;
            }
            
            // Update metrics
            if (metricsContent && stepData) {
                const metrics = [];
                Object.keys(stepData).forEach(key => {
                    if (key !== 'output_image_base64' && key !== 'input_image_base64' && typeof stepData[key] !== 'object') {
                        metrics.push(`<strong>${key}:</strong> ${stepData[key]}`);
                    }
                });
                metricsContent.innerHTML = metrics.length > 0 ? metrics.join('<br>') : 'No metrics available';
            } else if (metricsContent) {
                metricsContent.innerHTML = 'Step not executed yet. Click "Re-execute Step" to process.';
            }
            
            // Render visualization if applicable
            renderStepVisualization(stepId, stepData, current);
            
            // Scroll to viewer
            viewer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        };
        
        // Close step detail viewer
        window.closeStepDetailViewer = function() {
            const viewer = document.getElementById('step-detail-viewer');
            if (viewer) {
                viewer.style.display = 'none';
            }
            currentSelectedStep = null;
        };
        
        // Render visualization for step
        function renderStepVisualization(stepId, stepData, current) {
            const canvas = document.getElementById('step-visualization-canvas');
            const container = document.getElementById('step-visualization');
            if (!canvas || !container) return;
            
            // Hide by default, show only if we have visualization data
            container.style.display = 'none';
            
            if (!stepData || !current) return;
            
            // Get the image to draw on
            const img = new Image();
            const originalUrl = current.original_url || (current.path ? `https://storage.googleapis.com/${current.bucket || GCS_BUCKETS[0]}/${current.path}` : '');
            
            img.onload = function() {
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                // Draw step-specific visualizations
                if (stepId === 2 && stepData.edge_detection) {
                    // Edge detection visualization
                    drawEdgeVisualization(ctx, stepData);
                    container.style.display = 'block';
                } else if (stepId === 4 && stepData.grid_detection) {
                    // Grid detection visualization
                    drawGridVisualization(ctx, stepData);
                    container.style.display = 'block';
                } else if (stepId === 5 && stepData.smudge_mask) {
                    // Smudge removal visualization
                    drawSmudgeVisualization(ctx, stepData);
                    container.style.display = 'block';
                }
            };
            
            img.src = originalUrl;
        }
        
        // Draw edge detection visualization
        function drawEdgeVisualization(ctx, stepData) {
            if (!stepData.bounding_box) return;
            
            const bbox = stepData.bounding_box;
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
        }
        
        // Draw grid detection visualization
        function drawGridVisualization(ctx, stepData) {
            // Draw grid lines if available
            if (stepData.horizontal_lines) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 1;
                stepData.horizontal_lines.forEach(line => {
                    ctx.beginPath();
                    ctx.moveTo(line.x1 || 0, line.y || 0);
                    ctx.lineTo(line.x2 || ctx.canvas.width, line.y || 0);
                    ctx.stroke();
                });
            }
            
            if (stepData.vertical_lines) {
                ctx.strokeStyle = '#0000ff';
                ctx.lineWidth = 1;
                stepData.vertical_lines.forEach(line => {
                    ctx.beginPath();
                    ctx.moveTo(line.x || 0, line.y1 || 0);
                    ctx.lineTo(line.x || 0, line.y2 || ctx.canvas.height);
                    ctx.stroke();
                });
            }
        }
        
        // Draw smudge removal visualization
        function drawSmudgeVisualization(ctx, stepData) {
            if (!stepData.smudge_mask) return;
            
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            // Note: Would need to decode smudge_mask from base64 or array
            // This is a placeholder
        }
        
        // Re-execute a step
        window.reExecuteStep = async function(stepId, stepIndex) {
            const current = currentComparisonImages[currentComparisonIndex];
            if (!current) {
                alert('No image selected');
                return;
            }
            
            const step = PROCESSING_STEPS[stepIndex];
            if (!step) return;
            
            // Show loading state
            const stepItem = document.querySelector(`.processing-step-item[data-step-id="${stepId}"]`);
            if (stepItem) {
                stepItem.style.opacity = '0.5';
                stepItem.style.pointerEvents = 'none';
            }
            
            try {
                // Get original image
                const originalUrl = current.original_url || (current.path ? `https://storage.googleapis.com/${current.bucket || GCS_BUCKETS[0]}/${current.path}` : '');
                
                // Fetch image and convert to base64
                const response = await fetch(originalUrl);
                const blob = await response.blob();
                const reader = new FileReader();
                
                reader.onloadend = async function() {
                    const base64data = reader.result.split(',')[1];
                    
                    // Call execute-step endpoint
                    const executeResponse = await fetch(`${PYTHON_SERVICE_URL}/execute-step`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            step_id: stepId,
                            method_id: step.method_id,
                            image: base64data,
                            previous_result: stepResults[stepId - 1] || {}
                        })
                    });
                    
                    if (!executeResponse.ok) {
                        throw new Error(`HTTP error! status: ${executeResponse.status}`);
                    }
                    
                    const result = await executeResponse.json();
                    
                    if (result.success) {
                        // Store result
                        stepResults[stepId] = result;
                        
                        // Update step data in current image
                        if (!current.steps) current.steps = {};
                        const stepKey = getStepKey(stepId);
                        
                        // Special handling for color separation - store trace and grid images
                        if (stepId === 2 && result.grid_mask) {
                            // Color separation returns trace_image and grid_mask
                            // Convert grid_mask to image if needed
                            current.steps[stepKey] = {
                                ...result.metrics,
                                output_image_base64: result.output_image, // This is trace_image
                                trace_image_base64: result.output_image,
                                grid_mask_base64: result.grid_mask, // May need conversion
                                input_image_base64: result.input_image
                            };
                        } else {
                            current.steps[stepKey] = {
                                ...result.metrics,
                                output_image_base64: result.output_image,
                                input_image_base64: result.input_image
                            };
                        }
                        
                        // Refresh checklist
                        renderProcessingChecklist(current);
                        
                        // If step detail viewer is open, refresh it
                        if (currentSelectedStep && currentSelectedStep.stepId === stepId) {
                            viewStepDetails(stepId, stepIndex);
                        }
                        
                        alert(`Step "${step.name}" executed successfully!`);
                    } else {
                        throw new Error(result.error || 'Step execution failed');
                    }
                };
                
                reader.readAsDataURL(blob);
                
            } catch (error) {
                console.error('Error re-executing step:', error);
                alert(`Error executing step: ${error.message}`);
            } finally {
                if (stepItem) {
                    stepItem.style.opacity = '1';
                    stepItem.style.pointerEvents = 'auto';
                }
            }
        };
        
        // Get step key from step ID
        function getStepKey(stepId) {
            const keyMap = {
                0: 'assumptions',
                1: 'quality_gates',
                2: 'color_separation',
                3: 'illumination_normalization',
                4: 'grid_detection',
                5: 'smudge_removal',
                6: 'rotation_correction',
                7: 'fft_reconstruction',
                8: 'grid_line_detection',
                9: 'grid_spacing',
                10: 'affine_transform',
                11: 'trace_extraction',
                12: 'apply_transform',
                13: 'skeletonize',
                14: 'trace_to_signal',
                15: 'post_process'
            };
            return keyMap[stepId] || 'unknown';
        }
        
        // Download step image
        window.downloadStepImage = function() {
            const afterImg = document.getElementById('step-after-image');
            if (!afterImg || !afterImg.src) {
                alert('No image to download');
                return;
            }
            
            const link = document.createElement('a');
            link.href = afterImg.src;
            link.download = `step-${currentSelectedStep?.stepId || 'processed'}.png`;
            link.click();
        };
        
        // Render processing stages
        function renderProcessingStages(current) {
            const stagesList = document.getElementById('processing-stages-list');
            if (!stagesList) return;
            
            const stages = [];
            
            // Check which stages ran based on the result data
            if (current.steps) {
                // Stage 1: Image Loading
                if (current.steps.image_loading) {
                    stages.push({
                        name: 'Image Loading',
                        status: current.steps.image_loading.image_loaded ? 'completed' : 'failed',
                        details: current.steps.image_loading.image_loaded ? 'Image loaded successfully' : 'Failed to load image'
                    });
                }
                
                // Stage 2: Quality Gates
                if (current.steps.quality_gates) {
                    stages.push({
                        name: 'Quality Check',
                        status: current.steps.quality_gates.quality_passed ? 'completed' : 'failed',
                        details: `Blur: ${current.steps.quality_gates.blur_score?.toFixed(1) || 'N/A'}, DPI: ${current.steps.quality_gates.dpi || 'N/A'}`
                    });
                }
                
                // Stage 3: Color Analysis
                if (current.steps.color_analysis) {
                    const hasRed = current.steps.color_analysis.has_red;
                    const hasBlack = current.steps.color_analysis.has_black;
                    const hasBoth = current.steps.color_analysis.has_both_colors;
                    
                    stages.push({
                        name: 'Color Analysis',
                        status: 'completed',
                        details: hasBoth ? '‚úì Red AND Black detected' : (hasRed ? 'Red detected' : hasBlack ? 'Black detected' : 'No color detected')
                    });
                }
                
                // Stage 4: Edge Detection
                if (current.steps.edge_detection) {
                    stages.push({
                        name: 'Edge Detection',
                        status: current.steps.edge_detection.edges_detected ? 'completed' : 'skipped',
                        details: current.steps.edge_detection.edges_detected ? 
                            `Found ${current.steps.edge_detection.edge_pixels || 0} edge pixels` : 'No edges detected'
                    });
                }
                
                // Stage 5: Color Separation
                if (current.steps.color_separation) {
                    const splitGenerated = current.steps.color_separation.split_images_generated;
                    stages.push({
                        name: 'Color Separation',
                        status: 'completed',
                        details: splitGenerated ? '‚úì Split images generated (red & black)' : 
                                `Method: ${current.steps.color_separation.method || 'lab'}, Trace: ${current.steps.color_separation.trace_pixels || 0}px`
                    });
                }
                
                // Stage 6: Grid Detection
                if (current.steps.grid_detection) {
                    stages.push({
                        name: 'Grid Detection',
                        status: current.steps.grid_detection.grid_detected ? 'completed' : 'skipped',
                        details: current.steps.grid_detection.grid_detected ?
                            `Fine: ${current.steps.grid_detection.fine_lines || 0}, Bold: ${current.steps.grid_detection.bold_lines || 0}` : 
                            'No grid detected'
                    });
                }
                
                // Stage 7: Smudge Removal
                if (current.steps.smudge_removal) {
                    stages.push({
                        name: 'Smudge Removal',
                        status: current.steps.smudge_removal.smudges_detected ? 'completed' : 'skipped',
                        details: current.steps.smudge_removal.smudges_detected ?
                            `Removed ${current.steps.smudge_removal.smudge_count || 0} smudges` : 'No smudges found'
                    });
                }
            }
            
            // If no stages data, show basic info
            if (stages.length === 0) {
                stages.push({
                    name: 'Processing',
                    status: current.success ? 'completed' : 'failed',
                    details: current.success ? 'Processing completed' : (current.error || 'Processing failed')
                });
            }
            
            // Render stages
            stagesList.innerHTML = stages.map(stage => {
                const statusColor = stage.status === 'completed' ? '#28a745' : 
                                   stage.status === 'failed' ? '#dc3545' : '#6c757d';
                const statusIcon = stage.status === 'completed' ? '‚úì' : 
                                  stage.status === 'failed' ? '‚úó' : '‚óã';
                
                return `
                    <div style="padding: 0.75rem; background: white; border-radius: 0.375rem; border-left: 3px solid ${statusColor};">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                            <span style="color: ${statusColor}; font-weight: bold;">${statusIcon}</span>
                            <strong style="font-size: 0.875rem;">${stage.name}</strong>
                        </div>
                        <div style="font-size: 0.75rem; color: #666; margin-left: 1.5rem;">
                            ${stage.details}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Render thumbnail strip
        function renderThumbnails() {
            const strip = document.getElementById('thumbnail-strip');
            if (!strip) return;
            
            strip.innerHTML = currentComparisonImages.map((img, index) => {
                const isActive = index === currentComparisonIndex;
                const thumbUrl = img.thumbnail_url || 
                               img.processed_url || 
                               img.original_url ||
                               (img.path ? `https://storage.googleapis.com/${img.bucket || GCS_BUCKETS[0]}/${img.path}` : '') ||
                               img.url;
                const fileName = img.original_name || img.name || img.path?.split('/').pop() || 'Unknown';
                // Escape HTML in filename for safety
                const safeFileName = fileName.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                return `
                    <div class="thumbnail-item ${isActive ? 'active' : ''}" 
                         onclick="navigateToImage(${index})"
                         style="cursor: pointer; position: relative;"
                         title="${fileName}"
                         onmouseenter="showThumbnailTooltip(event)"
                         onmouseleave="hideThumbnailTooltip(event)">
                        <img src="${thumbUrl}" alt="${fileName}" 
                             onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 24 24\\'%3E%3Ctext x=\\'50%25\\' y=\\'50%25\\' text-anchor=\\'middle\\'%3E?%3C/text%3E%3C/svg%3E'">
                        <div class="thumbnail-filename-tooltip">${safeFileName}</div>
                    </div>
                `;
            }).join('');
        }
        
        // Show thumbnail tooltip on hover
        window.showThumbnailTooltip = function(event, fileName) {
            const tooltip = event.currentTarget.querySelector('.thumbnail-filename-tooltip');
            if (tooltip) {
                tooltip.style.display = 'block';
            }
        };
        
        // Hide thumbnail tooltip
        window.hideThumbnailTooltip = function(event) {
            const tooltip = event.currentTarget.querySelector('.thumbnail-filename-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        };
        
        // Navigate to specific image
        window.navigateToImage = function(index) {
            if (index >= 0 && index < currentComparisonImages.length) {
                currentComparisonIndex = index;
                renderComparison();
            }
        };
        
        // Update overlays
        // Update fade comparison
        window.updateFadeComparison = function(value) {
            const fadeProcessed = document.getElementById('fade-processed');
            const fadePercentage = document.getElementById('fade-percentage');
            
            if (fadeProcessed) {
                // Convert slider value (0-100) to opacity (0 = original, 100 = processed)
                // At 0: show only original (processed opacity = 0)
                // At 50: show both equally (processed opacity = 0.5)
                // At 100: show only processed (processed opacity = 1)
                const opacity = value / 100;
                fadeProcessed.style.opacity = opacity;
            }
            
            if (fadePercentage) {
                updateFadePercentage(value);
            }
        };
        
        function updateFadePercentage(value) {
            const fadePercentage = document.getElementById('fade-percentage');
            if (fadePercentage) {
                fadePercentage.textContent = value + '%';
                // Color code: red for original, blue for processed
                if (value < 50) {
                    fadePercentage.style.color = '#667eea'; // More original
                } else if (value > 50) {
                    fadePercentage.style.color = '#764ba2'; // More processed
                } else {
                    fadePercentage.style.color = '#667eea'; // Equal
                }
            }
        }
        
        window.updateOverlays = function() {
            const showEdges = document.getElementById('toggle-edges')?.checked || false;
            const showSmudges = document.getElementById('toggle-smudges')?.checked || false;
            const showGrid = document.getElementById('toggle-grid')?.checked || false;
            
            console.log('Overlays:', { showEdges, showSmudges, showGrid });
            
            // Get all image elements in the comparison view
            const groundTruthImg = document.getElementById('comparison-ground-truth');
            const originalImg = document.getElementById('comparison-original');
            const processedImg = document.getElementById('comparison-processed');
            
            // Apply overlays to all visible images
            if (groundTruthImg) {
                applyOverlaysToImage(groundTruthImg, showEdges, showSmudges, showGrid, 'ground-truth');
            }
            if (originalImg) {
                applyOverlaysToImage(originalImg, showEdges, showSmudges, showGrid, 'original');
            }
            if (processedImg) {
                applyOverlaysToImage(processedImg, showEdges, showSmudges, showGrid, 'processed');
            }
        };
        
        // Cache for edge/grid detection results per image URL
        const edgeDetectionCache = new Map();
        const gridDetectionCache = new Map();
        
        // Detect edges for an image
        async function detectEdgesForImage(imageUrl, imageType) {
            // Check cache first
            if (edgeDetectionCache.has(imageUrl)) {
                return edgeDetectionCache.get(imageUrl);
            }
            
            try {
                // Fetch image and convert to base64
                const response = await fetch(imageUrl);
                const blob = await response.blob();
                const reader = new FileReader();
                
                return new Promise((resolve) => {
                    reader.onloadend = async function() {
                        const base64data = reader.result.split(',')[1];
                        
                        try {
                            // Call edge detection endpoint
                            const detectResponse = await fetch(`${PYTHON_SERVICE_URL}/detect-edges`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    image: base64data,
                                    method: 'canny',
                                    crop: false
                                })
                            });
                            
                            if (detectResponse.ok) {
                                const result = await detectResponse.json();
                                if (result.success && result.edges_detected) {
                                    const edgeData = {
                                        edges_detected: true,
                                        edge_pixels: result.edge_pixels || 0,
                                        bounding_box: result.bounding_box || null
                                    };
                                    edgeDetectionCache.set(imageUrl, edgeData);
                                    resolve(edgeData);
                                } else {
                                    resolve({ edges_detected: false, edge_pixels: 0 });
                                }
                            } else {
                                resolve({ edges_detected: false, edge_pixels: 0 });
                            }
                        } catch (error) {
                            console.error('Error detecting edges:', error);
                            resolve({ edges_detected: false, edge_pixels: 0 });
                        }
                    };
                    
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error fetching image for edge detection:', error);
                return { edges_detected: false, edge_pixels: 0 };
            }
        }
        
        // Detect grid for an image
        async function detectGridForImage(imageUrl, imageType) {
            // Check cache first
            if (gridDetectionCache.has(imageUrl)) {
                return gridDetectionCache.get(imageUrl);
            }
            
            try {
                // Fetch image and convert to base64
                const response = await fetch(imageUrl);
                const blob = await response.blob();
                const reader = new FileReader();
                
                return new Promise((resolve) => {
                    reader.onloadend = async function() {
                        const base64data = reader.result.split(',')[1];
                        
                        try {
                            // Call grid detection via execute-step endpoint
                            const detectResponse = await fetch(`${PYTHON_SERVICE_URL}/execute-step`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    step_id: 4, // Multi-Scale Grid Detection
                                    method_id: 'default',
                                    image: base64data,
                                    previous_result: {}
                                })
                            });
                            
                            if (detectResponse.ok) {
                                const result = await detectResponse.json();
                                if (result.success && result.metrics) {
                                    const gridData = {
                                        grid_detected: true,
                                        fine_lines: result.metrics.mm1_lines || 0,
                                        bold_lines: result.metrics.mm5_lines || 0,
                                        horizontal_lines: result.grid_lines?.horizontal || [],
                                        vertical_lines: result.grid_lines?.vertical || []
                                    };
                                    gridDetectionCache.set(imageUrl, gridData);
                                    resolve(gridData);
                                } else {
                                    resolve({ grid_detected: false, fine_lines: 0, bold_lines: 0 });
                                }
                            } else {
                                resolve({ grid_detected: false, fine_lines: 0, bold_lines: 0 });
                            }
                        } catch (error) {
                            console.error('Error detecting grid:', error);
                            resolve({ grid_detected: false, fine_lines: 0, bold_lines: 0 });
                        }
                    };
                    
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error fetching image for grid detection:', error);
                return { grid_detected: false, fine_lines: 0, bold_lines: 0 };
            }
        }
        
        // Apply overlays to an image element
        async function applyOverlaysToImage(imgElement, showEdges, showSmudges, showGrid, imageType) {
            if (!imgElement || !imgElement.complete) {
                // Wait for image to load
                imgElement.onload = () => applyOverlaysToImage(imgElement, showEdges, showSmudges, showGrid, imageType);
                return;
            }
            
            // Get the current image data
            const current = currentComparisonImages[currentComparisonIndex];
            if (!current) return;
            
            // Get image URL based on type
            let imageUrl = imgElement.src;
            if (imageType === 'ground-truth') {
                // For ground truth, we need to detect edges/grid on it
                imageUrl = imgElement.src;
            } else if (imageType === 'original') {
                imageUrl = current.original_url || imgElement.src;
            } else if (imageType === 'processed') {
                imageUrl = current.processed_url || current.original_url || imgElement.src;
            }
            
            // Create canvas overlay
            const canvasId = `overlay-canvas-${imageType}`;
            let canvas = document.getElementById(canvasId);
            
            const container = imgElement.parentElement;
            if (!container) return;
            
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.id = canvasId;
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.pointerEvents = 'none';
                canvas.style.zIndex = '10';
                
                container.style.position = 'relative';
                container.appendChild(canvas);
            }
            
            // Set canvas size to match image display size
            const imgRect = imgElement.getBoundingClientRect();
            const imgDisplayWidth = imgElement.offsetWidth || imgRect.width;
            const imgDisplayHeight = imgElement.offsetHeight || imgRect.height;
            
            canvas.width = imgDisplayWidth;
            canvas.height = imgDisplayHeight;
            canvas.style.width = imgDisplayWidth + 'px';
            canvas.style.height = imgDisplayHeight + 'px';
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // If no overlays, hide canvas
            if (!showEdges && !showSmudges && !showGrid) {
                canvas.style.display = 'none';
                return;
            }
            
            canvas.style.display = 'block';
            
            // Scale factor for drawing (account for image natural size vs display size)
            const scaleX = canvas.width / (imgElement.naturalWidth || imgElement.width || 1);
            const scaleY = canvas.height / (imgElement.naturalHeight || imgElement.height || 1);
            
            // Get or compute edge detection for this image
            let edgeData = null;
            if (showEdges) {
                // Try to get from current.steps first
                if (current.steps && current.steps.edge_detection && current.steps.edge_detection.edges_detected) {
                    edgeData = current.steps.edge_detection;
                } else {
                    // Auto-detect edges for this image
                    edgeData = await detectEdgesForImage(imageUrl, imageType);
                }
            }
            
            // Get or compute grid detection for this image
            let gridData = null;
            if (showGrid) {
                // Try to get from current.steps first
                if (current.steps && current.steps.grid_detection && current.steps.grid_detection.grid_detected) {
                    gridData = current.steps.grid_detection;
                } else {
                    // Auto-detect grid for this image
                    gridData = await detectGridForImage(imageUrl, imageType);
                }
            }
            
            // Draw edges overlay
            if (showEdges && edgeData) {
                ctx.strokeStyle = '#00ff00'; // Green for edges
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                // Draw bounding box if available
                if (edgeData.bounding_box) {
                    const bbox = edgeData.bounding_box;
                    ctx.rect(
                        bbox.x * scaleX,
                        bbox.y * scaleY,
                        bbox.width * scaleX,
                        bbox.height * scaleY
                    );
                }
                
                // Draw edge pixels if available
                if (edgeData.edge_pixels && edgeData.edge_pixels > 0) {
                    // Draw a sample pattern to indicate edges detected
                    const spacing = Math.min(canvas.width, canvas.height) / 30;
                    for (let x = 0; x < canvas.width; x += spacing) {
                        for (let y = 0; y < canvas.height; y += spacing) {
                            ctx.fillRect(x, y, 2, 2);
                        }
                    }
                }
                ctx.stroke();
            }
            
            // Draw grid overlay
            if (showGrid && gridData) {
                // Draw horizontal lines
                if (gridData.horizontal_lines && Array.isArray(gridData.horizontal_lines)) {
                    ctx.strokeStyle = '#ff0000'; // Red for horizontal grid lines
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    gridData.horizontal_lines.forEach(line => {
                        const y = (line.y || line.y1 || 0) * scaleY;
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                    });
                    ctx.stroke();
                }
                
                // Draw vertical lines
                if (gridData.vertical_lines && Array.isArray(gridData.vertical_lines)) {
                    ctx.strokeStyle = '#0000ff'; // Blue for vertical grid lines
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    gridData.vertical_lines.forEach(line => {
                        const x = (line.x || line.x1 || 0) * scaleX;
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                    });
                    ctx.stroke();
                }
                
                // If no specific lines, draw estimated grid pattern
                if ((!gridData.horizontal_lines || gridData.horizontal_lines.length === 0) &&
                    (!gridData.vertical_lines || gridData.vertical_lines.length === 0)) {
                    const fineLines = gridData.fine_lines || 0;
                    const boldLines = gridData.bold_lines || 0;
                    
                    if (fineLines > 0 || boldLines > 0) {
                        // Estimate grid spacing
                        const estimatedSpacing = Math.min(canvas.width, canvas.height) / Math.max(fineLines, boldLines, 20);
                        
                        ctx.strokeStyle = '#0000ff';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        
                        // Draw fine grid (1mm)
                        for (let i = 0; i < canvas.width; i += estimatedSpacing) {
                            ctx.moveTo(i, 0);
                            ctx.lineTo(i, canvas.height);
                        }
                        for (let i = 0; i < canvas.height; i += estimatedSpacing) {
                            ctx.moveTo(0, i);
                            ctx.lineTo(canvas.width, i);
                        }
                        ctx.stroke();
                        
                        // Draw bold grid (5mm) - every 5th line
                        ctx.strokeStyle = '#0000aa';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        for (let i = 0; i < canvas.width; i += estimatedSpacing * 5) {
                            ctx.moveTo(i, 0);
                            ctx.lineTo(i, canvas.height);
                        }
                        for (let i = 0; i < canvas.height; i += estimatedSpacing * 5) {
                            ctx.moveTo(0, i);
                            ctx.lineTo(canvas.width, i);
                        }
                        ctx.stroke();
                    }
                }
            }
            
            // Draw smudges overlay
            if (showSmudges && current.metrics && current.metrics.smudges) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; // Red with transparency for smudges
                // Draw smudge areas if available
                const smudgeCount = current.metrics.smudges.smudge_count || 0;
                if (smudgeCount > 0) {
                    // Draw sample smudge indicators
                    const radius = 10;
                    for (let i = 0; i < Math.min(smudgeCount, 10); i++) {
                        const x = (canvas.width / 10) * i + radius;
                        const y = canvas.height / 2;
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
            }
        };
        
        // Choose random group
        window.chooseRandomGroup = function() {
            if (allGroups.length === 0) {
                alert('No groups available');
                return;
            }
            
            const randomIndex = Math.floor(Math.random() * allGroups.length);
            const randomGroup = allGroups[randomIndex];
            currentSetIndex = randomIndex;
            
            // Update dropdown to show selected group
            const dropdown = document.getElementById('group-selector');
            if (dropdown) {
                dropdown.value = randomGroup.key;
            }
            
            // Scroll to the selected group
            scrollToGroup(randomGroup.key);
            
            console.log('Selected random group:', randomGroup.key);
        };
        
        // Choose next set
        window.chooseNextSet = function() {
            if (allGroups.length === 0) {
                alert('No groups available');
                return;
            }
            
            // Move to next set
            currentSetIndex = (currentSetIndex + 1) % allGroups.length;
            const nextGroup = allGroups[currentSetIndex];
            
            // Update dropdown to show selected group
            const dropdown = document.getElementById('group-selector');
            if (dropdown) {
                dropdown.value = nextGroup.key;
            }
            
            // Scroll to the selected group
            scrollToGroup(nextGroup.key);
            
            console.log('Selected next set:', nextGroup.key, `(${currentSetIndex + 1}/${allGroups.length})`);
        };
        
        // Add more sets to view
        window.addMoreSets = function() {
            // Load more groups
            renderGroups();
        };
        
        // Toggle collapse/expand for a group
        window.toggleGroupCollapse = function(groupKey, event) {
            if (event) {
                event.stopPropagation();
            }
            
            if (collapsedGroups.has(groupKey)) {
                collapsedGroups.delete(groupKey);
            } else {
                collapsedGroups.add(groupKey);
            }
            
            // Find and toggle visibility of images in this group
            const existingHeader = document.querySelector(`.gallery-group-header[data-group-key="${groupKey}"]`);
            if (existingHeader) {
                // Update collapse button icon
                const collapseBtn = existingHeader.querySelector('button[onclick*="toggleGroupCollapse"]');
                if (collapseBtn) {
                    collapseBtn.textContent = collapsedGroups.has(groupKey) ? '‚ñ∂' : '‚ñº';
                }
                
                // Show/hide images in this group
                let nextSibling = existingHeader.nextSibling;
                while (nextSibling) {
                    const item = nextSibling;
                    nextSibling = item.nextSibling;
                    
                    if (item.dataset && item.dataset.groupKey === groupKey) {
                        // This is an image item in this group
                        item.style.display = collapsedGroups.has(groupKey) ? 'none' : '';
                    } else if (item.id && item.id.startsWith(`progress-${groupKey}`)) {
                        // Progress indicator
                        item.style.display = collapsedGroups.has(groupKey) ? 'none' : '';
                    } else if (item.classList && item.classList.contains('gallery-group-header')) {
                        // Reached next group, stop
                        break;
                    } else {
                        // Unknown element, continue
                        continue;
                    }
                }
            }
        };
        
        // Scroll to a specific group
        function scrollToGroup(groupKey) {
            // Find the group
            const groupIndex = allGroups.findIndex(g => g.key === groupKey);
            if (groupIndex < 0) {
                console.warn('Group not found:', groupKey);
                return;
            }
            
            // Make sure the group is displayed (load more if needed)
            if (groupIndex >= displayedGroups) {
                // Load groups up to and including this one
                while (displayedGroups <= groupIndex) {
                    const beforeCount = displayedGroups;
                    renderGroups();
                    // Safety check to prevent infinite loop
                    if (displayedGroups === beforeCount) {
                        break;
                    }
                }
            }
            
            // Wait a bit for DOM to update, then scroll
            setTimeout(() => {
                const groupHeader = document.querySelector(`.gallery-group-header[data-group-key="${groupKey}"]`);
                if (groupHeader) {
                    groupHeader.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Highlight it briefly
                    const originalBg = groupHeader.style.background;
                    groupHeader.style.background = '#fff3cd';
                    groupHeader.style.transition = 'background 0.3s';
                    setTimeout(() => {
                        groupHeader.style.background = originalBg || 'var(--card-bg)';
                    }, 2000);
                } else {
                    console.warn('Group header not found after loading:', groupKey);
                }
            }, 100);
        }
        
        // Handle dropdown selection change
        window.selectGroupFromDropdown = function() {
            const dropdown = document.getElementById('group-selector');
            if (dropdown && dropdown.value) {
                scrollToGroup(dropdown.value);
            }
        };
        
        // Reset processing for a group
        window.resetGroupProcessing = function(groupKey) {
            if (confirm(`Reset processing status for group ${groupKey}?`)) {
                processedImages.delete(groupKey);
                processingGroups.delete(groupKey);
                
                // Update the button
                updateProcessButton(groupKey, false, false);
                
                // Update dropdown indicator
                updateGroupDropdown();
                
                // Remove any progress indicators
                const progressContainer = document.getElementById(`progress-${groupKey}`);
                if (progressContainer && progressContainer.parentNode) {
                    progressContainer.parentNode.removeChild(progressContainer);
                }
                
                // Update group header to remove processed status
                const groupHeader = document.querySelector(`.gallery-group-header[data-group-key="${groupKey}"]`);
                if (groupHeader) {
                    const h2 = groupHeader.querySelector('h2');
                    if (h2) {
                        // Remove processed badge
                        h2.innerHTML = h2.innerHTML.replace(/ <span style="color: green[^>]*>‚úì Processed<\/span>/, '');
                        h2.innerHTML = h2.innerHTML.replace(/ <span style="color: orange[^>]*>‚è≥ Processing<\/span>/, '');
                    }
                    
                    // Remove reset button
                    const resetBtn = groupHeader.querySelector('.reset-group-btn');
                    if (resetBtn && resetBtn.parentNode) {
                        resetBtn.parentNode.removeChild(resetBtn);
                    }
                }
                
                console.log(`Reset processing for group: ${groupKey}`);
            }
        };
        
        // Populate group dropdown
        function populateGroupDropdown() {
            const dropdown = document.getElementById('group-selector');
            if (!dropdown) return;
            
            // Clear existing options (except the first placeholder)
            while (dropdown.options.length > 1) {
                dropdown.remove(1);
            }
            
            // Add all groups
            allGroups.forEach(group => {
                const option = document.createElement('option');
                option.value = group.key;
                const groupLabel = group.folder || group.key;
                const groupType = group.is_train ? 'üìö Train' : group.is_test ? 'üß™ Test' : 'üìÅ';
                option.text = `${groupType} ${groupLabel} (${group.images.length} images)`;
                dropdown.appendChild(option);
            });
            
            // Update status indicators
            updateGroupDropdown();
        }
        
        // Update group dropdown with processing status
        function updateGroupDropdown() {
            const dropdown = document.getElementById('group-selector');
            if (!dropdown) return;
            
            // Update each option to show processing status
            Array.from(dropdown.options).forEach(option => {
                if (option.value) {
                    const isProcessed = processedImages.has(option.value);
                    const isProcessing = processingGroups.has(option.value);
                    
                    // Remove existing indicators
                    let text = option.text;
                    if (text.includes(' ‚úì') || text.includes(' ‚è≥')) {
                        text = text.split(' ‚úì')[0].split(' ‚è≥')[0];
                    }
                    
                    // Add status indicator
                    if (isProcessing) {
                        option.text = `${text} ‚è≥`;
                    } else if (isProcessed) {
                        option.text = `${text} ‚úì`;
                    } else {
                        option.text = text;
                    }
                }
            });
        }
    </script>
    
    <!-- WebSocket Client (optional, for future use) -->
    <script src="websocket_client.js"></script>
</head>
<body>
    <div class="gallery-container">
        <header>
            <h1>ECG Image Gallery</h1>
            <div style="margin-top: 10px; display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                <a href="/index.html" style="color: var(--primary-color); text-decoration: underline;">‚Üê Back to Upload</a>
                <button id="choose-random-btn" onclick="chooseRandomGroup()" 
                        style="padding: 0.5rem 1rem; background: #6c757d; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;">
                    üé≤ Choose Random Set
                </button>
                <button id="choose-next-btn" onclick="chooseNextSet()" 
                        style="padding: 0.5rem 1rem; background: #17a2b8; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;"
                        title="Navigate to the next set">
                    ‚è≠Ô∏è Next Set
                </button>
                <button id="add-more-sets-btn" onclick="addMoreSets()" 
                        style="padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;"
                        title="Load more sets">
                    ‚ûï Add More Sets
                </button>
            </div>
        </header>
        
        <main>
            <div id="loading" class="loading">Loading images...</div>
            <div id="gallery-grid" class="gallery-grid"></div>
        </main>
        
        <footer class="version-footer">
            <div class="version-info" id="version-info-container" onclick="copyVersionInfo()" title="Click to copy version info">
                <span>Version: <span id="app-version">Loading...</span></span>
                <span class="separator">|</span>
                <span>Build: <span id="app-build-timestamp">Loading...</span></span>
                <span class="separator">|</span>
                <span>Deployed: <span id="app-build-date">Loading...</span></span>
                <span class="separator">|</span>
                <span>Firebase SDK: <span id="app-firebase-sdk">10.7.1</span></span>
            </div>
            <button class="version-copy-btn" id="version-copy-btn" onclick="copyVersionInfo()">üìã Copy</button>
        </footer>
    </div>
    
    <!-- Comparison Modal -->
    <div id="comparison-modal" class="comparison-modal" style="display: none;">
        <div class="comparison-modal-content">
            <div class="comparison-header">
                <h2 id="comparison-title">Image Comparison</h2>
                <button class="modal-close" onclick="closeComparisonModal()">&times;</button>
            </div>
            
            <!-- Thumbnail Strip -->
            <div class="thumbnail-strip" id="thumbnail-strip"></div>
            
            <!-- View Mode Selector -->
            <div class="view-mode-selector" style="margin: 1rem 0; padding: 1rem; background: #f8f9fa; border-radius: 0.5rem; display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap;">
                <button class="view-mode-btn active" data-view="side-by-side" onclick="switchViewMode('side-by-side')" 
                        style="padding: 0.75rem 1.5rem; background: var(--primary-color); color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-weight: 500;">
                    üìä View 1: Side-by-Side
                </button>
                <button class="view-mode-btn" data-view="fade" onclick="switchViewMode('fade')"
                        style="padding: 0.75rem 1.5rem; background: #6c757d; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-weight: 500;">
                    üîÄ View 2: Fade Comparison
                </button>
                <button class="view-mode-btn" data-view="step-by-step" onclick="switchViewMode('step-by-step')"
                        style="padding: 0.75rem 1.5rem; background: #6c757d; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-weight: 500;">
                    üîÑ View 3: Step-by-Step
                </button>
            </div>
            
            <!-- Main Comparison Area -->
            <div class="comparison-main">
                <!-- Navigation Arrows -->
                <button class="nav-arrow nav-left" onclick="navigateImage(-1)">‚Üê</button>
                <button class="nav-arrow nav-right" onclick="navigateImage(1)">‚Üí</button>
                
                <!-- View 1: Side-by-Side All 3 Images -->
                <div id="view-side-by-side" class="view-container">
                    <div class="comparison-images" style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                    <div class="image-panel" id="panel-original" style="flex: 1; min-width: 250px; max-width: 33%;">
                        <h3>1. Original (Raw Input)</h3>
                        <img id="comparison-original" src="" alt="Original" style="width: 100%; height: auto; border-radius: 0.5rem;">
                        <p id="comparison-original-name" class="image-name"></p>
                    </div>
                    <div class="image-panel" id="panel-ground-truth" style="flex: 1; min-width: 250px; max-width: 33%;">
                        <h3>2. Ground Truth (Reference)</h3>
                        <img id="comparison-ground-truth" src="" alt="Ground Truth" style="width: 100%; height: auto; border-radius: 0.5rem;">
                        <p id="comparison-ground-truth-name" class="image-name"></p>
                    </div>
                    <div class="image-panel" id="panel-processed" style="flex: 1; min-width: 250px; max-width: 33%;">
                        <h3>3. Processed (Result)</h3>
                        <img id="comparison-processed" src="" alt="Processed" style="width: 100%; height: auto; border-radius: 0.5rem;">
                        <p id="comparison-processed-name" class="image-name"></p>
                    </div>
                </div>
                </div>
                
                <!-- View 2: Fade Comparison (Ground Truth vs Processed) -->
                <div id="view-fade" class="view-container" style="display: none;">
                    <div class="fade-comparison-container" style="margin-top: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 0.5rem;">
                    <h3 style="margin-top: 0; margin-bottom: 1rem;">üîÄ Before/After Fade Comparison</h3>
                    <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                        <span style="font-weight: 500; color: #333;">Original</span>
                        <input type="range" id="fade-slider" min="0" max="100" value="50" 
                               style="flex: 1; height: 8px; border-radius: 4px; background: linear-gradient(to right, #667eea 0%, #764ba2 100%); outline: none;"
                               oninput="updateFadeComparison(this.value)">
                        <span style="font-weight: 500; color: #333;">Processed</span>
                        <span id="fade-percentage" style="min-width: 50px; text-align: center; font-weight: bold; color: #667eea;">50%</span>
                    </div>
                    <div class="fade-image-container" style="position: relative; width: 100%; max-width: 800px; margin: 0 auto; border: 2px solid #ddd; border-radius: 8px; overflow: hidden; background: #fff;">
                        <img id="fade-original" src="" alt="Original" 
                             style="width: 100%; height: auto; display: block; position: relative; z-index: 1;">
                        <img id="fade-processed" src="" alt="Processed" 
                             style="width: 100%; height: auto; display: block; position: absolute; top: 0; left: 0; z-index: 2; opacity: 0.5;">
                    </div>
                    <div style="text-align: center; margin-top: 0.5rem; font-size: 0.875rem; color: #666;">
                        <span>Drag slider to fade between ground truth and processed images</span>
                    </div>
                    </div>
                </div>
                
                <!-- View 3: Step-by-Step Transformation -->
                <div id="view-step-by-step" class="view-container" style="display: none;">
                    <div class="step-by-step-container" style="margin-top: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 0.5rem;">
                        <h3 style="margin-top: 0; margin-bottom: 1rem;">üîÑ Interactive Processing Checklist</h3>
                        <p style="margin-bottom: 1rem; color: #666; font-size: 0.875rem;">Click any step to view transformation details. Use "Re-execute" to reprocess individual steps.</p>
                        
                        <!-- Processing Steps Checklist -->
                        <div id="processing-checklist" style="display: grid; gap: 0.75rem; margin-bottom: 1.5rem;">
                            <!-- Steps will be populated dynamically -->
                        </div>
                        
                        <!-- Step Detail Viewer (shown when step is clicked) -->
                        <div id="step-detail-viewer" style="display: none; margin-top: 1.5rem; padding: 1rem; background: white; border-radius: 0.5rem; border: 2px solid var(--primary-color);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                                <h4 id="step-detail-title" style="margin: 0; color: var(--primary-color);">Step Details</h4>
                                <button onclick="closeStepDetailViewer()" style="background: #dc3545; color: white; border: none; border-radius: 0.25rem; padding: 0.25rem 0.5rem; cursor: pointer;">‚úï Close</button>
                            </div>
                            
                            <!-- Before/After Image Comparison -->
                            <div id="step-images-container" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                                <div>
                                    <h5 style="margin: 0 0 0.5rem 0; color: #666; font-size: 0.875rem;">Before</h5>
                                    <div style="border: 1px solid #ddd; border-radius: 0.5rem; overflow: hidden; background: #f8f9fa;">
                                        <img id="step-before-image" src="" alt="Before" style="width: 100%; height: auto; display: block;">
                                    </div>
                                </div>
                                <div>
                                    <h5 id="step-after-label" style="margin: 0 0 0.5rem 0; color: #666; font-size: 0.875rem;">After</h5>
                                    <div style="border: 1px solid #ddd; border-radius: 0.5rem; overflow: hidden; background: #f8f9fa;">
                                        <img id="step-after-image" src="" alt="After" style="width: 100%; height: auto; display: block;">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Step Metrics -->
                            <div id="step-metrics" style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 0.5rem;">
                                <h5 style="margin: 0 0 0.5rem 0; font-size: 0.875rem;">Metrics</h5>
                                <div id="step-metrics-content" style="font-size: 0.875rem; color: #666;">Loading metrics...</div>
                            </div>
                            
                            <!-- Visualization Canvas (for edge detection, grid, etc.) -->
                            <div id="step-visualization" style="margin-bottom: 1rem;">
                                <h5 style="margin: 0 0 0.5rem 0; font-size: 0.875rem;">Visualization</h5>
                                <canvas id="step-visualization-canvas" style="width: 100%; max-width: 800px; border: 1px solid #ddd; border-radius: 0.5rem; background: white;"></canvas>
                            </div>
                            
                            <!-- Action Buttons -->
                            <div style="display: flex; gap: 0.5rem;">
                                <button id="step-re-execute-btn" onclick="reExecuteStep()" style="flex: 1; padding: 0.75rem; background: var(--primary-color); color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-weight: 500;">
                                    üîÑ Re-execute Step
                                </button>
                                <button onclick="downloadStepImage()" style="padding: 0.75rem 1rem; background: #28a745; color: white; border: none; border-radius: 0.375rem; cursor: pointer;">
                                    üíæ Download
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Processing Stages Panel -->
            <div class="processing-stages-panel" style="margin-bottom: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 0.5rem;">
                <h3 style="margin-top: 0;">Processing Stages</h3>
                <div id="processing-stages-list" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.75rem;">
                    <!-- Stages will be populated dynamically -->
                </div>
            </div>
            
            <!-- Metrics Panel -->
            <div class="metrics-panel">
                <h3>Metrics</h3>
                <div class="metrics-grid">
                    <div class="metric-item">
                        <label>SNR (ECG Trace Only):</label>
                        <span id="metric-snr-trace">--</span> dB
                        <small style="display: block; color: #666; font-size: 0.75rem; margin-top: 0.25rem;">Signal-to-noise ratio for ECG trace (excluding grid)</small>
                    </div>
                    <div class="metric-item">
                        <label>SNR (Overall):</label>
                        <span id="metric-snr">--</span> dB
                    </div>
                    <div class="metric-item">
                        <label>Image Type:</label>
                        <span id="metric-type">--</span>
                    </div>
                    <div class="metric-item">
                        <label>Contrast:</label>
                        <span id="metric-contrast">--</span>
                    </div>
                    <div class="metric-item">
                        <label>Smudges:</label>
                        <span id="metric-smudges">--</span>
                    </div>
                </div>
                
                <!-- Toggle Overlays -->
                <div class="overlay-toggles" style="margin-top: 1rem;">
                    <label><input type="checkbox" id="toggle-edges" onchange="updateOverlays()"> Show Edges</label>
                    <label><input type="checkbox" id="toggle-smudges" onchange="updateOverlays()"> Show Smudges</label>
                    <label><input type="checkbox" id="toggle-grid" onchange="updateOverlays()"> Show Grid</label>
                </div>
            </div>
        </div>
    </div>
    
    <style>
        .comparison-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .comparison-modal-content {
            max-width: 1400px;
            margin: 2rem auto;
            background: white;
            border-radius: 0.5rem;
            padding: 2rem;
            position: relative;
        }
        
        .comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: #666;
        }
        
        .thumbnail-strip {
            display: flex;
            gap: 0.5rem;
            padding: 1rem;
            background: #f5f5f5;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            overflow-x: auto;
        }
        
        .thumbnail-item {
            min-width: 80px;
            height: 80px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden;
        }
        
        .thumbnail-item.active {
            border-color: var(--primary-color);
        }
        
        .thumbnail-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .thumbnail-item {
            position: relative;
        }
        
        .thumbnail-filename-tooltip {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 0.5rem 0.75rem;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            z-index: 10001;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            max-width: 250px;
            word-break: break-all;
            white-space: normal;
            text-align: center;
            line-height: 1.4;
        }
        
        .thumbnail-filename-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }
        
        .comparison-main {
            position: relative;
            margin-bottom: 2rem;
        }
        
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: var(--primary-color);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 10;
        }
        
        .nav-left {
            left: -25px;
        }
        
        .nav-right {
            right: -25px;
        }
        
        .comparison-images {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        @media (max-width: 1200px) {
            .comparison-images {
                flex-direction: column;
                align-items: center;
            }
            .image-panel {
                max-width: 100% !important;
            }
        }
        
        .image-panel.hidden {
            display: none;
        }
        
        .image-panel {
            text-align: center;
            position: relative;
            flex: 1;
            min-width: 250px;
            max-width: 33%;
        }
        
        .image-panel img {
            width: 100%;
            height: auto;
            max-height: 500px;
            border: 1px solid #ddd;
            border-radius: 0.5rem;
            display: block;
            margin: 0 auto;
        }
        
        .image-name {
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: #666;
        }
        
        .view-container {
            width: 100%;
        }
        
        .view-mode-btn.active {
            background: var(--primary-color) !important;
            font-weight: bold;
        }
        
        .metrics-panel {
            border-top: 1px solid #ddd;
            padding-top: 1.5rem;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .metric-item {
            padding: 0.75rem;
            background: #f5f5f5;
            border-radius: 0.375rem;
        }
        
        .overlay-toggles {
            display: flex;
            gap: 1.5rem;
        }
        
        .overlay-toggles label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }
    </style>
</body>
</html>
